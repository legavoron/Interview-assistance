let question = document.querySelector('.pre_q');
let answer = document.querySelector('.pre_a');
let answerBtn = document.querySelector('.answer_btn');
let nextQuestionBtn = document.querySelector('.quest_btn');
let answerBlock = document.querySelector('.answer');
let num= 0;
let newImg;


let arr = [
    {
        q: 'Что такое Doctype? Для чего он используется?',
        a: `    Doctype используется для указания типа документа. Он добавляется первой строкой любого HTML документа.

    Служит для того, чтобы браузер мог понять, как ему интерпретировать страницу и в соответствии с каким стандартом парсить страницу`
    },
    {
        q: 'Базовая структура HTML страницы?',
        a: `    Первой строкой обязательно указывается Doctype

    <!DOCTYPE html>

    Затем тег <HTML> - контейнер, в котором содержится все содержимое страницы

    <html lang = 'en'>
    
    Далее тег <head>. Он содержит в себе все необходимые данные о HTML странице (заголовок, описание, SEO информация, подключение стилей,шрифтов)

    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    
    Далее <body>- Содержит в себе всю разметку HTML страницы. Здесь вся видимая часть страницы

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    <body>
    </body>
    </hed>
    </html>`
    },
    {
        q: `Что такое семантика? Какие семантические теги вы знаете?`,
        a: `    Семантика в HTML - это использование правильных тегов, которые описывают содержание контента внутри себя.
        
    Семантичный тег - это тег, который обладает каким-то пояснением своего предназначения.
    
    По тегу должно быть понятно, что внутри него находится.
    
    <header></header> - Шапка сайта

    <footer></footer> - подвал

    <aside></aside> - боковая панель

    <nav></nav> - навигация по сайту

    <main></main> - основное содержимое документа

    <p></p> - параграф

    <h1></h1> - заголовок

    <em></em> - курсив с семантикой

    <strong></strong> - жирный текст с семантикой

    <ul></ul> - маркированный список и т.д.`
    },
    {
        q: `Какая разница между тегами <strong>, <em> и <b>, <i>`,
        a: `    <strong> и <em> предназначены для придания элементу логического выделения.
        
    При чтении страницы поисковыми роботами или screen- ридарами на этих элементах будет сделан акцент`
    },
    {
        q: `Разница между call, apply и bind?`,
        a: `    Из-за запутанности кода может случиться ситуация, когда контекст this будет ссылаться не на тот объект, что нам нужен.
    
    Мы можем сами задать, на какой объект будет ссылаться this в определенной функции.
    
    function showName(firstName, lastName) {
        console.log(firstName + ' ' + lastName)
    }
    
    const user = {
        firstName: 'Ivan',
        lastName: 'Petrov'
    }
    
    Теперь указываем, для функции showName, что this внутри нее должен ссылаться на объект user.
    
    Для этого есть 3 способа:
    
    call
    
    showName.call(user, 'firstName', 'lastName) - функция showName сразу же вызовется и отработает
    
    apply

    showName.apply(user, ['firstName', 'lastName]) - функция showName сразу же вызовется и отработает

    В call параметры функции записываются через запятые, их может быть сколько угодно.
    А в apply может быть только два параметра. Поэтому первый параметр - это всегда объект, а остальные параметры просто записываются внутри массива.

    bind

    showName.bind(user, 'firstName', 'lastName)()

    Параметры также как и в call записываются через запятую. Но bind не вызывается сразу. Т.е. мы можем передать контекст, а функцию уже вызвать тогда, когда нам это нужно. Либо, если нужно сразу вызвать, то в конце указываем скобки ()`,
    i: 'apply'
    },
    {
        q: 'Что такое делигирование событий?',
        a: `    Делигирование - это прием разработки, когда вместо того, чтобы вешать кучу однотипных обработчиков событий на все элементы, можно добавить всего лишь один обработчик на общего родителя.

    Например: мы создаем таблицу и нам нужно, чтобы при нажатии на ячейку она закрашивалась в какой-либо цвет. Мы не вешаем обработчики на каждую ячейку (ячеек может быть и тысячи, тогда нам понадобятся тысячи обработчиков). Мы вешаем всего один обработчик на саму таблицу. 

    Далее мы просто указываем, что если элемента, по которому мы кликнули - это ячейка, то она должна закраситься нужным цветом`,
    i: 'delegation'
    },
    {
        q: `Что такое CSS и для чего он используется?`,
        a: `    CSS - расшифровывается как каскадная таблица стилей. Предназначена она для добавления различных стилей на HTML страницу.
        
    На CSS лежит задача добавления на страницу различных визуальных эффектов.
    
    Каскадная- означает, что мы можем подключать стили одновременно несколькими способами и все они будут работать.
    
    Наследование в CSS - означает, что если не указано иное, то конкретный стиль будет унаследован всеми такими же элементами, а также стиль будет применятся ко всем дочерним элементам. 
    
    Например, если мы добавим background-color к div, то все div на страницы изменят цвет и все вложенные элементы в этих div-ах также изменят цвет`
    },
    {
        q: `Варианты добавления CSS стилей на страницу?`,
        a: `    Есть 4 способа: 

    1. <div style="background-color: red></div>
    
    Добавляем стиль конкретному элементу прямо в его теге
    
    2. <head>
            <style>
                div {background-color: red}
            </style>
        </head>
        
    Добавляем стиль в тег <head> к определенным элементам
    
    3. <head>
            <link rel="stylesheet" href="css/style.css">
        </head>
        
    Прикрепляем CSS- файл
    
    4. @import "style/media.css"
        @import "style/footer.css"
       
    Импорты внутри файлов стилей`
    },
    {
        q: `Типы позиционирования в CSS`,
        a: `    Существует 5 типов позиционирования в CSS
        
    1. Static - устанавливается элементам по умолчанию
    
    2. Relative - элемент позиционируется относительно своего текущего положения
    
    3. Absolute - позиционирование относительно другого элемента, у которого позиционирование не Static.
       Если такого элемента нет, то относительно окна браузера

    4. Fixed - позиционирование только относительно окна браузера
    
    5. Sticky - в видимой части экрана элемент ведет себя как fixed. При дальнейшей прокрутке скроллится вместе с родителем`
    },
    {
        q: `Блочная модель CSS?`,
        a: `    Блочная модель позволяет посчитать, какое итоговое пространство будет занимать элемент на странице.
    
    В нее входит:
    
    - сам контент
    
    - padding
    
    - border
    
    - margin
    
    Общий размер элемента- это сумма этих размеров.
    
    Если нам нужно, чтобы размер элемента являлся заданному значению, то используем команду:
    
    box-sizing: border-box
    `,
    i: 'block_model_css'
    },
    {
        q: `Типы данных в CSS?`,
        a: `    В Java Script существует 8 типов данных
        
    1. String
    
    2. Number
    
    3. Bigint
    
    4. Boolean
    
    5. Symbol
    
    6. Object
    
    7. Null
    
    8. Undefined`
    },
    {
        q: `Строгий режим Strict Mode в Java Script?`,
        a: `    Строгий режим позволяет использовать более строгий вариант JS синтаксиса.
        
    Заменяет исключениями некоторые ошибки, которые интерпретатор JS раньше пропускал.
    Более опасные и не полезные черты JS теперь запрещены или приводят к ошибке
    
    Как подключить?

    1. "use strict"

    2. function func() {
            "use strict"
        }

    Строгий режим будет работать только внутри функции

    3. В ES-6 режим добавляется автоматически`
    },
    {
        q: `Какая разница между function declaration и function expression?`,
        a: `    function declaration

    function sum(a,b) {
        return a + b
    }
    
    function expression
    
    let sum = funcrion(a,b) {
        return a + b
    }
    
    function declaration можно вызывать до ее объявления, а function expression нельзя`
    },
    {
        q: `Что такое валидация? Типы проверок HTML - документа?`,
        a: `    Валидация - это проверка документа специальной программой - валидатором на соответствие установленным web стандартам и на обнаружение существующих ошибок.
    
    Эти стандарты называются спецификациями.
    
    Валидатор сначала определяет тип документа, который указывается с помощью Doctype.
    
    Затем проверяет HTML код на правильность и отсутствие ошибок. При этом проверяется правильность имен тегов и их вложенность.
    
    Проверить валидность можно на сайте:
    
    http://validator.w3.org`
    },
    {
        q: `Какой тег использовать, чтобы сверстать кнопку?`,
        a: `    Сразу нужно уточнить, а какая именно кнопка нужна.
        
    1. <button>Нажми</button> - обычная кнопка
    
    2. Кнопки подтверждения формы
    
    <button type="submit">Отправить</button>
    <input type="submit" value="button>
    
    3. <input type="button"> - устаревающий способ
    
    4. <a href="#">Button</a> - кнопка - ссылка. Дальше придаем стили, чтобы чтилизоват ее под кнопку`
    },
    {
        q: `Что такое инлайновый стиль? Можно ли его переопределить?`,
        a: `    Инлайновый стиль - это стиль, примененный к определенному элементу непосредственно в его теге в HTML.
        
    Переопределить его можно с помощью директивы !importmant
    
    <div style="text-align:center"></div>
    
    Чтобы перезаписать его (переопределить) вешаем !importmant на CSS свойство
    
    <style>
        div{text-align:left !importmant}
    </style>`
    },
    {
        q: `Что такое селектор? Какие селекторы существуют?`,
        a: `    Селектор - это часть CSS правила, которая сообщает браузеру, к какому элементу или элементам web страницы будет применен стиль.
        
    Все селекторы делятся на 2 группы
    
    1. Простые
    
    - .class
    
    - #id
    
    - p (тег)
    
     - * (универсальный селектор. Ставим * и дальше описываются правила (имя, класс и т.д.). Т.е. помогает выбрать абсолютно любой элемент со страницы)
     
     - a[href="text]
     
     2. Составные
     
     - h1, h2, span - перечисляем через запятую
     
     - div p - селектор потомка. Через пробел. Указывать можем всю цепочку вложенности
     
     - li > a - селектор только дочернего элемента
     
     - a:hover - селектор псевдокласса
     
     - li:nth-last-child(2n) - селектор псевдоэлемента`
    },
    {
        q:`Что такое специфичность селектора? Как считать вес селектора?`,
        a: `    Специфичность - это способ, с помощью которого браузер определяет, какие значения CSS свойств будут применены к элементу.
        
    Если на элементе висит сразу несколько свойств, повешенных разными способами, то нужно определить, какое из этих свойств будет применяться`
    },
    {
        q: `Разница между Reset.css и Normalize.css?`,
        a: `    Все HTML элементы обладают дефолтными стилями. И в разных браузерах эти стили разные.
        
    Чтобы во всех браузерах контент выглядел одинаково, перед тем как начинать верстку используют эти два метода.
    
    По сути это CSS файл, который подключается в самом начале документа.
    
    1. Reset - сбрасывает все стили и их нужно прописывать заново
    
    2. Normalize - прописываем стили, которые должны будут применяться везде одинаково`
    },
    {
        q: `Что такое поднятие (hoisting)?`,
        a: `    Hoisting - это механизм подъема функции или переменной в глобальную или функциональную область видимости
        
    Java Script сначала объявляет, а затем инициализирует переменные.
    
    Переменные, объявленные через var и функции function declaration можно использовать еще до объявления их значений.
    
    Если function declaration мы можем объявить хоть в самом конце кода, то с var работает не так.
    
    Hoisting работает с объявлением, но инициализация будет только в момент присваивания значения.
    
    Т.е. объявить-то var мы можем в самом конце кода, но пока мы не передадим ей какое - либо значение, переменная через var при обращении к ней будет выдавать undefined
    
    А переменные, объявленные через let и const при обращении к ним до их объявления будут выводить не undefined а ошибку
    
    console.log(a); // undefined
    var a = 20;`
    },
    {
        q: `Типы таймеров в Java Script?`,
        a: `    Есть 2 типа таймеров
    1. setTimeout() - вызывает переданную функцию один раз через указанный промежуток времени

    2. setInterval - будет вызывать функцию постоянно через указанные промежутки времени
    
    clearTimeout - позволяет остановить setTimeout до его вызова
    
    clearInterval - позволяет остановить setInterval. Перед этим setInterval записываем в переменную и ее передаем параметром в clearInterval`
    },
    {
        q: `Типы списков в HTML?`,
        a: `    Есть 3 типа списков
    1. Маркированный <ul></ul>
    
    2. Нумерованный <ol></ol>
    
    3. Список определений 
    
    <dl>
        <dt>Определение</dt>
        <dd>Поясняющий текст</dd>
    </dl>`
    },
    {
        q: `Как семантически правильно сверстать картинку с подписью?`,
        a: `    Нужно использовать сначала тег <figure>

    <figure><img><figcaption>Поясняющий текст</figcaption></figure>

    При этом использование этих тегов не отменяет того, что внутри тега <img> нужно указывать alt

    Перед пояснением <figcaption> может идти несколько изображений и тогда пояснение будет одно для них` 
    },
    {
        q: `Разница между display:none и visibility:hidden?`,
        a: `    Оба правила предназначены для того, чтобы скрывать элемент на странице.
        
    display:none - полностью убирает элемент с HTML страницы. Единственное место, где он останется - это DOM дерево
    
    Контент внутри скрытого таким образом блока становится недоступно для поисковых роботов
    
    visibility:hidden - на HTML странице элемент становится не виден, но из основного потока он не вырывается и по прежнему занимает отведенное для него место. А также он остается доступен для поисковых роботов`
    },
    {
        q: `Разница между блочными и строчными (инлайновыми) элементами?`,
        a: `    Основная разница между блочными и строчными элементами в том, что по умолчанию блочный элемент будет занимать всю ширину экрана, а строчный элемент имеет ширину его содержимого.
        
    Поэтому блочные элементы идут друг под другом, а строчные в одну линию.
    
    Также блочным элементам можно задавать размеры (ширину и высоту), а для строчных это не работает.
    
    Блочные элементы воспринимают margin и padding, а для строчных элементов margin сверху и снизу не работает`
    },
    {
        q: `Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?`,
        a: `    Адаптивный дизайн - это по сути несколько версий одного и того же сайта, которые загружаются пользователю в зависимости от устройства, на котором открыт сайт.
    Пользователь заходит на сайт, браузер определяет тип устройства, с которого пользователь зашел и отправляет его на специально разработанную для этого устройства версию сайта.
        
    Responsive - это один и тот же дизайн, который автоматически сжимается в зависимости от ширины экрана`
    },
    {
        q: `Что такое область видимости (scope)?`,
        a: `    Область видимости или scope - это место, откуда мы имеем доступ к переменным или функциям.
    В JS есть 3 типа областей видимости:
    
    1. Глобальная
    
    2. Функциональная - переменные и функции, объявленные внутри функции доступны только внутри это  функции и всем ее вложенностям
    
    3. Блочная - новая область видимости, которая появилась в ES-6 для переменных, объявленных через let и const
    
    Это область видимости, которая находится между фигурными скобками {}, так называемого блока. Это например (if... else, цикл for)
    
    Переменные, объявленные через var, такую область видимости игнорируют. Т.е. если мы внутри if ... else объявим переменную через var, то она просто станет глобальной`
    },
    {
        q: `Разница между var, let и  const`,
        a: `    var - подвержены всплытию. Если мы обратимся к переменной, объявленной через var до присваивания ей значения (до ее инициализации), то получим просто undefined, а у let и const в таком случаем нам выведет ошибку
        
    У let и const область видимости ограничена блоком, т.е. фигурными скобками. У var область видимости ограничена только функцией
    
    Если let и const объявлены внутри фигурных скобок, то они доступны только внутри них и на всех вложенных уровнях
    
    Переменная, объявленная через var такую область видимости игнорирует и может быть видна за ее пределами
    
    const - невозможно переопределить, т.е. нельзя присвоит ей новое значение`
    },
    {
        q: `Что такое функции высшего порядка?`,
        a: `    Функции высшего порядка - это функции, которые возвращают другие функции или же принимают другую функцию в качестве аргумента
        
    Например: 
    
    let higherOrderFunction = (params, callback) => {
        return callback(params)
    }
    
    К ним относятся такие функции (методы) как :
    
    - map;
    
    - filter
    
    - forEach и т.д.`
    },
    {
        q: `Что такое DOM?`,
        a: `    DOM - это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML кода
        
    Если просто, HTML - это текст, а DOM - это набор связанных объектов, которые создает браузер при парсинге этого текста
    
    Каждый объект соответствует каждому тегу и они вложены друг в друга, как и теги в HTML. Вложенность похожа на форму дерева - поэтому называется DOM- дерево`
    },
    {
        q: `Что такое распространение события (event propogation)?`,
        a: `    Распространение события - это механизм, который отрабатывает когда какое-либо событие происходит в документе
        
    События распространяются от объекта window до вызывающего его элемента. При этом событие последовательно затрагивает всех предков целевого документа
    
    Есть 3 основные фазы распространения событий:
    
    1. capture - событие проходит от корня документа по DOM дереву до целевого элемента. Это фаза захвата
    
    2. target - событие достигает целевого элемента. Обычно его называют event target
    
    3. bubbling - всплытие. Событие возвращается обратно до window, параллельно вызывая все события на родительских элементах`
    },
    {
        q: `Что такое HTML и для чего он используется?`,
        a: `    HTML - это язык гипертекстовой разметки, позволяющий составлять форматированный текст
        
    Данный текст интерпретируется браузером. После чего браузер отображает этот текст на экране в виде элементов web- страницы

    По сути это скелет или каркас любой web- страницы, содержащий разметку

    Основная задача - помочь браузеру понять, как отобразить информацию и какого типа информация используется на странице`
    },
    {
        q: `Расскажите о регулярных выражениях`,
        a: `    Регулярные выражения - это шаблоны, которые используются для сопоставления последовательностей символов в строках
        
    Если проще - то для поиска и замены символов в строке
    
    2 способа создания:
    
    - new RegExp('pattern', 'flags')
    
    - /pattern/flags
    
    Например ищем букву 'n' в слове
    
    const str = prompt('Введите имя);
    const reg = /n/
    console.log(str.search(reg))
    
    Вызываем метод search у той строки, в которой ищем. В ответе получим номер элемента первого совпадения. Если совпадений нет, то получим -1
    
    Чтобы искать не просто первое совпадение, а различные варианты, используются флаги
    
    i - ищем без учета регистра
    
    g - ищем все совпадения, а не только первое
    
    m - если строка идет в несколько строк
    
    Метод search не работает с флагом 'g', потому что сам по себе находит только первое совпадение
    
    
    Метод match - возвращает массив, в котором указывается паттерн, индекс, строка, в которой искали. А если будет стоять флаг g, и будет несколько совпадений, то нам вернется массив, в котором будет буква, которую мы ищем, столько раз, сколько раз ее найдет
    
    console.log('java script'.match(/a/g)) // ['a','a']
    
    
    Метод replace - заменяет найденный элемент на другой указанный элемент

    Например заменим все буквы 'a' на '*'
    let str = 'java script';
    console.log(str.replace(/a/g, '*) // 'j*v* script'
    
    
    
    Фишка - если в replace написать /./, то точка - это любой символ. 
    Например 

    let pas = prompt('Введите пароль')
    console.log(pas.replase(/./g, '*')) // все символы заменятся на звездочки
    
    
    А если нужно найти именно точку, то экранируем ее с помощью обратного слэша \
    
    сonsole.log(str.replace(/\.g, '*')) // заменит все точки на звездочки
    
    Также ищем символ слэша /, и другие символы
    
    
    Метод test - возвращает true или false, если найдет или не найдет совпадение/
    Тут немного другой синтаксис: сначала указываем, что ищем, потом, где ищем
    
    let str = 'jsvs script';
    console.log(/a/ig.test(str)) // true, т.к. есть символ 'a'
    
    
    В регулярных выражениях есть специальные классы
    
    /\d/ - ищет все цифры
    /\w/ - ищет все буквы
    /\s/ - ищет все пробелы
    
    console.log(str.match(/\d/g)) // вернет массив с цифрами
    
    Классы можно комбинировать
    
    let str = 'My name is R2D2
    console.log(str.match(/\w\d\w\d/i))
    
    ищем связку буква- цифра- буква- цифра
    
    
    Обратные классы - когда наоборот нужно найти не цифры, не буквы, не пробелы

    Тоже самое, только используем большие буквы

    /\D/ - ищем не цифры
    /\W/ - ищем не буквы
    /\S/ -ищем не пробелы

    Не забываем ставит флаг 'g'

    Допустим задача, нам приходит ширина элемента 200px, нам нужно ее изменить, т.е. нам нужна только цифра 200

    let width = 200px;
    let numWidth = width.replace(/\D/g, '')

    Находим все, что не цифры и заменяем их на пустую строку, остаются только цифры`
    },
    {
        q: `Что такое элемент canvas и для чего он используется?`,
        a: `    canvas или "холст" - это HTML-5 элемент, который можно использовать для вставки изображений, градиентов и сложной анимации
        
    Также он создает область, в которой с помощью js можно рисовать различные объекты`
    },
    {
        q: `Что такое CSS правило?`,
        a: `    CSS- правило, т.е. базовый синтаксис
    Оно состоит из двух основных составляющих
    - селектор
    - свойства, которые будут к нему применятся
    
    Например
    div{
        background-color: blue;
    }`
    },
    {
        q: `Разница между классом и идентификатором в CSS?`,
        a: `    Для добавления стилей лучше всего использовать класс, а для добавления логики через js использовать идентификатор id
        
    У id больший вес. Он может использоваться на странице только один раз, т.е. не может быть несколько элементов с одним id
    
    Class можно вешать на несколько элементов. У одного элемента может быть несколько классов`,
    i: 'id_vs_class'
    },
    {
        q: `Что такое CSS спрайт и для чего он нужен?`,
        a: `    CSS спрайт - это картинка, которая объединяет несколько изображений в одно большое
    
    Грубо говоря, на одной картинке нарисованы несколько иконок, которые используются на сайте
    
    Чтобы не грузить много изображений, не обращаться за этим постоянно к серверу, рисуют их на одной картинке, она загружается, а потом с помощью css указывается, где какая часть этой большой картинки используется, т.е. какая иконка будет видна
    
    Плюс в том, что опять же к серверу обращаемся только один раз, второе это выполнение предзагрузки пока еще невидимого контента. Иконка, которая появляется при наведении будет уже загружена заранее. В результате не будет видно мигания при смене картинок`
    },
    {
        q: `Как превратить любой тип данных в булевый? Перечислите ложные значения в js`,
        a: `    Чтобы любой тип данных перевести в true или false можно использовать два подхода
    
    1. Boolean() - внутрь передаем данные и получаем true или  false
    
    2. использовать оператор двойного отрицания !!
    
    В JS есть 6 основных элементов, которые возвращают false
    
    - '' пустая строка
    - 0 ноль
    - null
    - undefined
    - NaN
    - false`
    },
    {
        q: `Методы строк в Java Script`,
        a: `    Основные
    
    - length 
    
    - charAt(1) - вернет второй символ
    
    - toUpperCase
    
    - toLowerCase
    
    - indexOf('a') - верне номер элемента, который совпадает с a, или -1, если совпадений нет
    
    - lastIndexOf('a') - вернет номер последнего совпадения
    
    - slice - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substring - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substr - второй параметр - сколько символов обрезать
    
    - replace('a', 'b') - найдет символ 'a' И заменит его на 'b'
    
    - split - разбивает в массив
    
    - includes('a') - вернет true, если в строке есть символ 'a'
    
    - startWidth('a') - вернет true, если строка начинается с 'a', 
    
    - endsWidth('a') - вернет true, если строка заканчивается с 'a'`
    },
    {
        q: `Методы массивов в JS`,
        a: `    Основные
        
    - length
    
    - push - добавить элемент в конец массива
    
    - unshift - добавить элемент в начало
    
    - pop - удалить последний элемент
    
    - shift - удалить первый элемент
    
    - splice - изменяет исходный массив! Удаляет и добавляет новые элементы в массив.
    Первый параметр - номер элемента, который удаляем. Второй параметр - сколько элементов удаляем. Третий - что вставляем вместо них
    
    - slice - не изменяет исходный массив! копирует значения в новый
    
    - join
    
    - toString - также переводит массив в строку
    
    - concat - несколько массивов объединяет в один
    
    - forEach - ничего не возвращает, просто проходит циклом
    
    - map - возвращает новый массив, изменяет элементы
    
    - reduce - запоминает промежуточный результат
    
    - filter - возвращает новый массив с элементами, которые соответствуют условию
    
    - sort - сортирует в в лексическом порядке
    
    - every - вернет true, если все элементы соответствуют условию
    
    - some - вернет true, если хотя бы один элемент соответствует условию`
    },
    {
        q: `Что такое цикл событий (event loop) и как он работает?`,
        a: `    Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти - стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

    Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.
    
    Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая - движок браузера ждет, когда поступит событие. Если непустая первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.`,
    i: 'event_loop',
    },
    {
        q: `Что такое статический метод класса (static)?`,
    a: `    Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.
    Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
    
    class Repo {
    static getName() {
        return "Repo name is modern-js-cheatsheet"
    }
    }

    // нам не нужно создавать объект класса Repo
    console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"

    let r = new Repo();
    console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией`
    },
    {
        q: `Что такое Set, Map, WeakSet и WeakMap?`,
        a: `    В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.

    Map – коллекция для хранения записей вида ключ - значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:
    
    'use strict';

    let map = new Map();

    map.set('1', 'str1');   // ключ-строка
    map.set(1, 'num1');     // число
    map.set(true, 'bool1'); // булевое значение

    // в обычном объекте это было бы одно и то же,
    // map сохраняет тип ключа
    alert( map.get(1)   ); // 'num1'
    alert( map.get('1') ); // 'str1'

    alert( map.size ); // 3
    
    
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
    
    'use strict';

    let set = new Set();

    let vasya = {name: "Вася"};
    let petya = {name: "Петя"};
    let dasha = {name: "Даша"};

    // посещения, некоторые пользователи заходят много раз
    set.add(vasya);
    set.add(petya);
    set.add(dasha);
    set.add(vasya);
    set.add(petya);

    // set сохраняет только уникальные значения
    alert( set.size ); // 3

    set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
    
    
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например, обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:
    
    // текущие активные пользователи
    let activeUsers = [
    {name: "Вася"},
    {name: "Петя"},
    {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент`
    },
    {
        q: `Какие методы жизненного цикла компонента существуют в React?`,
        a: `    render() — единственный обязательный метод в классовом компоненте.
    При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null
    
    constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
    Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
    Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().
    
    componentDidMount() - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
    Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
    
    componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
    
    componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    
    shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
    
    static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
    Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.
    
    getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
    
    static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().
    
    componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.`,
    i: 'react_metods_life_cicle'
    },
    {
        q: `Что такое Context в React и для чего он используется?`,
        a: `    Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).

    Контекст позволяет избежать передачи пропсов в промежуточные компоненты:
    
    // Контекст позволяет передавать значение глубоко
    // в дерево компонентов без явной передачи пропсов
    // на каждом уровне. Создадим контекст для текущей
    // UI-темы (со значением "light" по умолчанию).
    const ThemeContext = React.createContext('light');
    
    class App extends React.Component {
        render() {
        // Компонент Provider используется для передачи текущей
        // UI-темы вниз по дереву. Любой компонент может использовать
        // этот контекст и не важно, как глубоко он находится.
        // В этом примере мы передаём "dark" в качестве значения контекста.
        return (
            <ThemeContext.Provider value="dark">
            <Toolbar />
            </ThemeContext.Provider>
        );
        }
    }
    
    // Компонент, который находится в середине,
    // теперь не должен явно передавать UI-тему вниз.
    function Toolbar(props) {
        return (
        <div>
            <ThemedButton />
        </div>
        );
    }
    
    class ThemedButton extends React.Component {
        // Определяем contextType, чтобы получить значение контекста.
        // React найдёт (выше по дереву) ближайший Provider-компонент,
        // предоставляющий этот контекст, и использует его значение.
        // В этом примере значение UI-темы будет "dark".
        static contextType = ThemeContext;
        render() {
        return <Button theme={this.context} />;
        }
    }
    Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.
    
    API:
    React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
    Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.
    Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.
    Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext().`
    },
    {
        q: `Что такое Виртуальная DOM?`,
    a: `    Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

    Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.`
    },
    {
        q: `Для чего нужен атрибут key при рендере списков?`,
    a: `    Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.`
    },
    {
        q: `Как работает проп children?`,
    a: `    Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:

    function FancyBorder(props) {
        return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
            {props.children}
        </div>
        );
    }
    Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
    
    function WelcomeDialog() {
        return (
        <FancyBorder color="blue">
            <h1 className="Dialog-title">
            Добро пожаловать
            </h1>
            <p className="Dialog-message">
            Спасибо, что посетили наш космический корабль!
            </p>
        </FancyBorder>
        );
    }
    Всё, что находится внутри JSX-тега , передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.`
    },
    {
        q: `В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?`,
a: `    В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().

В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:

handleChange(event) {
    this.setState({value: event.target.value.toUpperCase()});
}
Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.

class NameForm extends React.Component {
    constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
    }

    handleSubmit(event) {
    alert('Отправленное имя: ' + this.input.current.value);
    event.preventDefault();
    }

    render() {
    return (
        <form onSubmit={this.handleSubmit}>
        <label>
            Имя:
            <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Отправить" />
        </form>
    );
    }
}
Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.`
    },
    {
        q: `Что такое PureComponent?`,
        a: `    React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.

    Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.
    
    Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние`
    },
    {
        q: `Что такое Компонент высшего порядка (Higher-Order Component, HOC)?`,
    a: `    Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.

    const EnhancedComponent = higherOrderComponent(WrappedComponent);
    Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:
    
    const CommentListWithSubscription = withSubscription(
        CommentList,
        (DataSource) => DataSource.getComments()
    );
    
    const BlogPostWithSubscription = withSubscription(
        BlogPost,
        (DataSource, props) => DataSource.getBlogPost(props.id)
    );
    Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.
    
    Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.`
    },
    {
        q: `Что такое порталы в React?`,
    a: `    Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

    ReactDOM.createPortal(child, container)
    Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
    
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.`
    },
    {
        q: `Что такое React Reconciliation (Cверка) и как он работает?`,
        a: `    Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.

    При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.
    
    Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля.
    
    При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
    
    По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.`
    },
    {
        q: `Можно создавать анимации в React?`,
        a: `    React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.`
    },
    {
        q: `Что выведет на экран следующий код?`,
        a: `    function b(x, y, a) {
                arguments[2] = 10;
                alert(a);
                }
                b(1, 2, 3);
        

        




    Ответ: 10

    Пояснение: В функции b 3 аргумента, индексы которых начинаются с [0]. Таким образом, аргумент с индексом [2]  — это a. В первой строке функции третьему аргументу функции присваивается значение 10.`
        
    },
    {
        q: `Что выведет в консоль следующий код?`,
        a: `    console.log(false == undefined);
    console.log(false == null);
    console.log(null == undefined);
    
    
    
    
    
    
    
    
    Ответ: false false true

    Пояснение: == сравнивает на равенство и не проверяет идентичность типов, поэтому в третьей строке кода в консоль будет выведено значение true.`
    },
    {
        q: `Что выведет в консоль следующий код?`,
        a: `    const numbers = [1, 2, 3, 4, 5];
    const [y] = numbers;
    console.log(y);
    
    
    
    
    
    
    
    
    
    
    
    Ответ: 1

    Пояснение: В данном примере выполнена деструктуризация. По умолчанию переменной у присваивается значение первого элемента массива.`
    },
    
    {
        q: `то выведет в консоль этот код?`,
        a: `    let x = 3;
    function fn() {
        x = 10;
        return;
        function x() {}
    }
    
    fn();
    console.log(x);
    
    
    
    
    
    
    
    
    
    
    
    Ответ:  3

    Пояснение:  х объявлена как функция, поэтому в итоге она перезаписалась с 10 на 3.`
    },
    {
        q: `Разница между e.preventDefault() и e.stopPropogation()?`,
        a: `    e.preventDefault() - отключает стандартное поведение элемента по умолчанию. Например он отменит переход по ссылке
        
    e.stopPropogation() - отключает распространение события (всплытие или погружение)`
    },
    {
        q: `Методы поиска элементов в DOM?`,
        a: `    -document.getElementById()

    -document.getElementByName()
    
    -document.getElementByTagName()
    
    -document.getElementByClassName()
    
    - querySelector()
    
    - querySelectorAll()`
    },
    {
        q: `Для чего используются Data- атрибуты?`,
        a: `    Использование data - атрибутов - устаревший подход
        
    data - атрибуты используются для хранения различной информации, которую в последующем можно было бы использовать в js для манипуляций
    
    Т.е. прямо в Dom- дереве можо хранить дополнительные данные
    
    Минус в безопасности, т.к. элемент можно изменить в консоли разработчика
    
    С появлением react, angular, vue от data- атрибутов стали отказываться

    
    <ul>
        <li data-price="40" data-weight="45>Pizza</li>
    </ul>
    
    
    Записывается как data- тире и любое название
    
    В CSS обращаемся как li[data-price=40]
    
    В js 

    let li = document.getElementByTagName('li');
    console.log(li..dataset.price)// 40`
    },
    {
        q: `Разница между <script>, <script async> и <script defer> ?`,
        a: `    Когда происходит парсинг HTML документа, парсер может наткнуться на тег <script>. В нем хранится Java Script код.
        
    Проблема в том, что когда парсер доходит до этого тега, <script> блокирует дальнейшее чтение документа до момента своего полного исполнения. Именно поэтому <script> принято добавлять в конец HTML документа перед закрывающим тегом </body>
    
    Если тег <script> содержит async, то он извлекается и исполняется параллельно с чтением HTML документа. Обычно async атрибут применяется для скриптов, которые не зависят от других скриптов на странице. Например это какая-нибудь аналитика
    
    defer - в этом случае скрипт будет извлечен при чтении HTML страницы, однако код js выполнится только после полного ее парсинга. Т.е. js код считывается параллельно HTML, но выполняться js код будет только когда вся HTML страница загружена
    
    Если скриптов с defer несколько, то они будут исполняться в том порядке, как они расположены в HTML документе.
    
    Его следует применять, если логика взаимодействует с DOM- элементами и нужно гарантировать, что код JS не начнет выполняться, пока DOM- дерево не загружено полностью
    
    
    Если тег <script> мы создаем в js коде (т.е. создали в js тег <script>, указали ему src и добавили с помощью append его в body) и через js подключаем несколько таких скриптов, то все они будут выполняться как async и не будут ждать друг друга
    
    function(src){
        let script= document.createElement('script);
        script.src = src;
        script.async = false; // убираем асинхронность
        document.body.append(script);
    }`
    },
    {
        q: `Для чего используется элемент datalist?`,
        a: `    datalist - это HTML-5 элемент, который используется для создания списка с автозаполнением при вводе символов
    
    Вешается он на обычный input- элемент
    Пользователь может либо выбрать что-либо из списка, либо ввести свое значение`,
        i: 'datalist'
    
    },
    {
        q: `Что такое вендорные префиксы и для чего они используются?`,
        a: `    Вендорный префикс - это приставка к css свойству, которая обеспечивает поддержку данного свойства браузерами, в которых оно не внедрено на постоянной основе
        
    Т.е. свойство введено в спецификацию CSS, но в конкретном браузере оно может быть еще в разработке или только тестируется
    
    `,
    i: 'vendor_prefixes'
    },
    {
        q: `Где можно посмотреть, как то или иное css свойство поддерживается в разных браузерах?`,
        a: `    Используем сайт can i use`
    },
    {
        q: `Разница между Progressive Enhancement И Graceful Gagradation?`,
        a: `    Это 2 подхода к созданию кроссплатформенных и кроссбраузерных приложений
        
    Progressive Enhancement предлагает поэтапное создание web интерфейсов от простого к сложному
    
    На каждом из этапов создается web интерфейс как улучшенная версия предыдущего
    
    
    Graceful Gagradation наоборот, сначала делаем сложную версию и потом упрощаем все до более ранних версий браузеров или до мобильной версии`
    },
    {
        q: `Что такое псевдоэлементы и для чего они используются?`,
        a: `    Псевдоэлемент - это ключевое слово, которое добавляется на селектор и позволяет стилизовать определенную часть выбранного элемента


    В CSS есть 5 типов псевдоэлементов:
    1. first-letter - изменяется первая буква в тексте

    2. first-line - изменяется первая строка блочного текста
    
    3. after - вставляется нужный контент после выбранного элемента
    
    4. before - вставляется нужный контент до выбранного элемента
    
    5. selection - позволяет применить стили для части элемента, которая была выделена пользователем`,
    i: 'psevdo_elem'
    },
    {
        q: `Что такое чистая функция?`,
        a: `    Чистая функция должна удовлетворять двум условиям
    
    1. В ней не должно быть побочных эффектов
    2. Каждый раз она должна возвращать одинаковый результат, когда в нее передаются одни и те же параметры
    
    Чистая функция не зависит от внешних элементов
    
    let x = 4;
    let add = (y)=> x + y;
    add(4);
    
    Мы будем передавать каждый раз 4, но в зависимости от значения переменной "х" мы получим разный результат. Т.е. эта функция не является чистой `,
    i: 'clean_function'
    },
    {
        q: `Разница между forEach() и map()?`,
        a: `    Эти методы применяются к массивам, чтобы на каждом элементе вызывать callback функцию
        
    Главное отличие в том, что forEach() перебирает массив и ничего не возвращает
    
    map - перебирает массив, формирует и возвращает новый массив. Этот новый массив мы можем присвоить в переменной и использовать дальше. 
    
    Оба метода не изменяют исходный массив, к которому они применяются`,
    i: 'forEach_vs_map'
    },
    {
        q: `Что такое "this" в Java Script?`,
        a: `    This - это контекст вызова, или ссылка на значение объекта, который в данный момент выполняет или вызывает функцию. Т.е. это объект до точки
        
    Контекст можно установить с помощью методов call(), apply() и bind()`,
        i: 'this'
    },
    {
        q: `Почему в js функции называют объектами первого класса?`,
        a: `    Объекты первого класса - это элементы, которые можно передать в функцию, вернуть из функции, присвоить переменным
        
    Собственно, все это можно сделать с функциями. `
    },
    {
        q: `Что такое схлопывание границ (margin collapsing)?`,
        a: `    Схлопывание границ - это механизм взаимодействия отступов по вертикали.
        
    Такой эффект наблюдается у блочных элементов, которые расположены друг под другом. Их отступы не суммируются. Отступ между ними становится равным не сумме их отступов, а равен значению большего из них`,
        i: 'margin_collapsing'
    },
    {
        q: `Что такое кроссбраузерность?`,
        a: `Это корректное отображение сайта в разных браузерах и на разных устройствах
        
    Т.е. созданный сайт должен одинаково выглядеть в разных браузерах
    
    
    Некоторые техники кроссбраузерности:
    
    - сематическая верстка
    - использование Rezet и Normalize
    - добавление вендорных префиксов
    - использование media запросов
    - использование полифилов и ранспиллиров`
    },
    {
        q: `Что такое CSS препроцессор?`,
        a: `    Это программа, которая позволяет генерировать CSS из собственного синтаксиса. Т.е. на выходе она дает сгенерированный CSS код
        
    В препроцессорах есть переменные, вложенность, переиспользуемые куски кода
    
    Синтаксис препроцессора удобнее чем синтаксис CSS
    
    Sass, Less, Stylus - наиболее популярные препроцессоры`
    },
    {
        q: `Как определить, есть ли в объекте такое-то свойство?`,
        a: `    Для того чтобы определить, присутствует ли в объекте указанное свойство, можно воспользоваться одним из трех способов
        
    1. hasOwnProperty() - вернет true или false

    2. console.log('prop1' in obj) - вернет true, если в объекте obj есть свойство prop1
    
    3. console.log(obj[prop1]) - вернет значение свойства prop1, если оно есть, а если его нет, то вернет undefined`
    },
    {
        q: `Что такое замыкание? Объясните принцип его работы`,
        a: `    При создании функции и объявлении внутри этой функции переменной, эта переменная будет видна только внутри этой функции и всем ее вложенностям. Снаружи получить доступ к этой переменной мы не можем
        
    На хранение таких переменных выделяется определенная память и когда функция заканчивает свое выполнение, эта память очищается и эта переменная больше нигде не существует
    
    Но если внутри функции создавать другую функцию, то эта функция получит доступ к нашей переменной, которая была объявлена в родительской функции
    
    Т.е. вложенная функция замыкает на себе переменную и аргументы внешней функции
    
    Чтобы создать замыкание, внешняя функция должна объявить переменную, а затем вернуть через return вложенную функцию
    
    Потом внешнюю функцию передаем в какую либо переменную`,
        i: 'closure'
    },
    {
        q: `ЧТо такое IIFE?`,
        a: `    Это переводится как анонимная самовызывающаяся функция. Она выполняется сразу же после создания`,
        i: 'IIFE'
    },
    {
        q: `Что такое всевдомассив аргументов?`,
        a: `    Arguments - это коллекция аргументов, которая передается в функцию
        
    Т.к. это псевдомассив, то у него работает только метод length
    
    Чтобы превратить псевдомассив в массив можно использовать 
    Array.prototype.slice.call(arguments)

    но проще использовать спред оператор 
    [...arguments]

    В стрелочных функциях псевдомассив arguments недоступен`,
    i: 'arguments'
    },
    {
        q: `Разница между host- объектами и нативными объектами`,
        a: `    Host- Объекты - это объекты, которые предоставляются средой выполнения, т.е. браузером для Front-end Иkb Node.js  для Back-end

    В браузере к ним можно отнести window, document, location, history
    
    Нативные объекты - это объекты, которые являются частью языка js. К ним можно отнести, например, объекты string, object, function`,
        i: "hostObjects_vs_nativeObjects"
    },
    {
        q: `Разница между event.target и event.currentTarget?`,
        a: `    event.target - это элемент, в котором происходит событие, или элемент, вызвавший событие
        
    event.currentTarget - это непосредственно элемент, к которому прикрепляем прослушиватель события
    
    Например, у нас есть <div>, а внутри div находится кнопка button. Мы вешаем обработчик события на div
    
    Дальше мы кликаем не на div а на кнопку
    
    event.target - выдаст нам button
    
    event.currentTarget - выжаст нам div, т.к. обработчик висит на нем`,
    },
    {
        q: `Разница между stopPropogation() и stopmediatePropogation()?`,
        a: `    При наступлении события в браузере происходит всплытие. В результате обработчики вызываются сначала на самом вложенном элементе и дальше вызываются обработчики всех родителей элемента по цепочке
        
    stopPropogation() и stopmediatePropogation() служат для остановки всплытия, чтобы не срабатывали все обработчики
    
    
    stopPropogation() отменяет дальнейшее всплытие, но на текущем элементе все обработчики срабатывают
    
    stopmediatePropogation() - отменяет дальнейшее всплытие и на текущем элементе обработчики не сработают тоже`,
    i: 'stopPropogation_vs_stopImediatePropogation'
    },
    {
        q: `Разница между событиями Load и  DOMContentLoad?`,
        a: `    Оба события срабатывают при загрузке страницы в браузере
        
    Разница между ними в том, что:

    DOMContentLoad отрабатывает, когда браузер полностью загрузил HTML, после чего было построено DOM- дерево, однако внешние ресурсы, по типу стилей, скриптов, картинок еще не прогружены
    
    load - это событие, когда браузер загрузил HTML и все зависимые внешние ресурсы (шрифты, стили, картинки и т.д.)
    
    Т.е. DOMContentLoad всегда сработает раньше чем load`,
    i: 'load_vs_DomContentLoad'
    },
    {
        q: `Разница между синхронными и асинхронными функциями?`,
        a: `    Синхронные функции являются блокирующими, а асинхронные нет
        
    Во время выполнения js кода, когда интерпретатор натыкается на синхронную функцию, он блокирует дальнейшее выполнение операций пока данная функция не будет выполнена
    Такие функции выполняются последовательно, одна за одной
    
    Асинхронные функции не блокируют дальнейшее выполнение скрипта
    Обычно такие функции в качестве аргумента принимают callback функцию, которая будет выполнена после того, как выполнится ассинхронная`,
    i: 'sync_vs_asyncFunction'
    },
    {
        q: `Что такое прогрессивный рендеринг?`,
        a: `    Это обобщенное название технологий, которые используются для ускорения отрисовки web страниц
        
    Основная идея - это как можно раньше показать пользователю визуальный контент. Основная задача - уменьшение скорости загрузки
    
    К технологиям прогрессивного рендеринга можно отнести:
    
    - ленивую загрузку картинок. Когда на странице загружаются не все картинки, а только те, что находятся в видимой области экрана. Это реализуется с помощью js
    
    - приоритетизация видимого контента. При этом подходе минимизируют и инкапсилируют стили, разметку и скрипты для той части страницы, которую пользователь увидит первой
    
    Для реализации можно использовать события DOMContentLoad и Load, либо как вариант применять асинхронные скрипты
    
    - асинхронные фрагменты HTML`
    },
    {
        q: ' Что выведется в консоли: console.log({} === {}) ?',
        a: `    false, т.к. объекты - это ссылочный тип данных и они ссылаются на разные участки памяти`
    },
    {
        q: `Что такое прототипное наследование? Как создать объект без прототипа?`,
        a: `    Все объекты в Java Script имеют свойство prototype, которое является ссылкой на другой объект
        
    Когда мы обращаемся к какому-либо свойству объекта и в этом объекте такого свойства нет. то механизм js просматривает прототип объекта и ищет это свойство там. Затем он идет в прототип прототипа и т.д.
    
    Чтобы создать объект, у которого нет прототипа, нужно воспользоваться командой
    
    let obj = Object.create(null)`
    },
    {
        q: `Почему расширение нативных Java Script объектов - плохая практика?`,
        a: `    Java Script использует механизм прототипного наследования, а это значит, что если свойство или метод не найде в текущем объекте, то поиск будет осуществляться дальше по прототипам.
        
    Расширение нативного объекта - это значит добавление новых свойств его прототипу
    
    Если мы добавляем новое свойство прототипу, у нас могут возникнуть проблемы. Например, при использовании сторонних библиотек, в них может быть свойство с таким же названием и потом возникнет конфликт или что-то будет работать некорректно`
    },
    {
        q: `Что такое NaN? Как определить, что значение равно NaN?`,
        a: `    NaN - 'not a number' - не число
        
    Это ненастраивоемое свойство глобального объекта. Появляется, когда математическая функция сработала неверно.
    Например parseInt('string') // NaN
    
    NaN Не равно ничему, включая самого себя
    NaN === NaN // false
    NaN == NaN // false
    
    Проверить, является ли значение NaN: isNaN('string') // NaN`
    },
    {
        q: `Что такое ECMAScript? В чем отличие ECMAScript от Java Script?`,
        a: `    ECMAScript - это спецификация, стандарт скриптового языка программирования
        
    Он содержит в себе правила, сведения и рекомендации, которые должны соблюдаться скриптовым языком, чтобы он считался совместимым с ECMAScript
    
    А Java Script - это как раз скриптовый язык программирования, который соответствует спецификации ECMAScript
    
    Самая новая версия ECMAScript - эот ES-6 или ES-2015`
    },
    {
        q: `Можно ли изменить значение, определенное через const?`,
        a: `    Можно изменить только свойства объекта, который присвоен переменной через const. Присвоить другой объект или другое значение в принципе, нельзя`
    },
    {
        q: `Что такое временная мертвая зона(temporal dead zone)?`,
        a: `    На самом деле let и const всплывают точно также как и var.
        
    Но чтобы легче было отлавливать ошибки, которые в ES-5 были вызваны всплыванием переменных, создали temporal dead zone
    
    Т.е. переменные по факту будут созданы, когда интерпретатор зайдет в область их видимости, но они будут недоступны, пока выполнение кода не дойдет до их фактического объявления. И только в этот момент произойдет их выход из временной мертвой зоны и с переменными можно будет работать`
    },
    {
        q: `Что такое AJAX?`,
        a: `    AJAX - ассинхронный Java Script и XML
        
    AJAX - 'это не технология сама по себе, а термин, который описывает подход к использованию нескольких существующих технологий для работы на стороне клиента и для создания ассинхронных web приложений
    
    С помощью AJAX web приложения могут отправлять данные на сервер и получать их с сервера ассинхронно
    
    А также с помощью AJAX страницы могут динамически изменять содержимое без перезагрузки страницы.
    
    На практике вместо формата XML используют формат JSON, т.к. он основан на Java Script`
    },
    {
        q: `Что такое same- otigin polisy в контексте Java Script?`,
        a: `    Это принцип одинакового источника. Определяет, как документ или скрипт, загруженный из данного источника, может взаимодействовать с ресурсом, загруженным из другого источника
        
    Этот принцип не позволяет Java Script выполнять запросы за границы домена. Это позволяет изолировать потенциально вредоносные документы. И не дает вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой`
    },
    {
        q: `Разница между attribute и property у DOM элементов?`,
        a: `    attribute - это значение, которое прописано в HTML. Оно не меняется
        
    Его можно посмотреть с помощью getAttribute(value)
    
    А property (свойство) - это вычисленное значение DOM элемента.
    Его можно менять и работать с ним`,
    i: 'attribute_vs_property'
    },
    {
        q: `Разница между HTMLCollection и NodeList?`,
        a: `    HTMLCollection - это динамическая HTML коллекция, которая представляет собой массивоподобный объект дочерних элементов
        
    NodeList - это список нод
    
    querySelectorAll - возвращает NodeList
    getElementsByClassName - возвращает HTMLCollection
    
    
    Отличие в том, что если в разметку динамически будет добавлен новый элемент, он добавится только в HTMLCollection, потому что это динамическая структура данных, а NodeList - статическая
    
    Т.е. NodeList один раз формируется и больше не изменяется`
    },
    {
        q: `Что такое объектая обертка (wrapper Objacts)?`,
        a: `    В Java Script типы данных - это примитивы и объекты. И у примитивов тоже есть свои методы
        
    Это возможно, как раз благодаря объектной обертке. Дело в том, что во время исполнения кода примитив временно преобразуется в объект
    
    Это аналогично тому, как если бы в момент применения метода использовался бы конструктор newString, например
    
    У каждого примитива, кроме null и undefined есть такой объект обертка
    
    После работы со свойством или методом, временный объект отбрасывается`
    },
    {
        q: `Как в Java Script создать объект?`,
        a: `    Есть 3 основных способаЖ
        
    1. let person = {
        name: 'Aleh'
    }
    
    2. Через функцию конструктор
    
    function Person(name) {
        this.name = name;
    }
    
    let man = new Person('Aleh')
    
    3. let person = Object.create(humans);
    
    person.name = 'Aleh
    
    В Object.create() указывается прототип`,
        i:'newObject'
    },   
    {
        q: `Для чего используется ключевое слово 'new'?`,
        a: `    Используется для создания функции - конструктора.
        
    Ключевое слово 'new' делает 4 вещи:
        
    1. Создает пустой объект
    2. Привязывает к созданному объекту значение this
    3. Каждый объект, созданный функцией, автоматически получает свойство prototype
    4. Возвращает значение this`,
        i: 'new'
    },
    {
        q: `Разница между Rest и  Spred операторами?`,
        a: `    Они имеют одинаковый синтаксис, но выполняют противоположные задачи
        
    Spred оператор используется для разделения коллекций на отдельные элементы
    
    Rest - наоборот, собирает отдельные значения в массив`,
        i: 'rest_vs_spred'
    },{
        q: `Что такое деструктуризация?`,
        a: `    Деструктуризация - это способ извлекать значения из объектов и массивов и помещать их в отдельные переменные
        
    Вместо того, чтобы каждый раз объявлять новые переменные и присваивать им значения из массива или объекта, переменные записываются в квадратных или фигурных скобках, дальше пишется равно и указывается объект или массив, деструктуризация данных которого должна произойти`,
        i: 'destructuring'
    },
    {
        q: `Что такое цикл событий (event loop) и как он работает?`,
        a: `    Движок в Java Script в одну единицу времени может выполнять только одну операцию. Для такого потока выделяется область памяти, которая называется стек.
        
    События, которые должны будут отработаться попадают в очередь событий. Когда стек освобождается, туда должно попасть следующее событие из очереди. Чтобы определить, какое именно событие из очереди попадет следующим в стек для выполнения, нужен event loop
    
    По сути - это бесконечный цикл, в котором выполняются многочисленные обработчики событий
    
    Если очередь пустая, то браузер ждет, когда поступит новое событие в очередь, а затем в стек
    
    Если очередь не пустая, то берется первое событие из очереди, закидывается в стек и начинает выполняться, а в event loop снова цикл проходит, вычисляя, какое событие пойдет отрабатываться следующим`,
       i:'eventLoop'
    },
    {
        q: `Что такое CORS?`,
        a: `    В целях безопасности браузеры ограничивают кроссдоменные запросы, которые создаются скриптами
        
    Т.е. XMLHTTPRequest и Fetch следуют политике источника.
    
    Web приложения, которые используют такие API, могут запрашивать ресурсы только с того домена, с которого они были загружены
    
    Этот принцип не позволяет JS выполнять запросы за границы домена
    
    CORS - это механизм, который использует дополнительный HTTP заголовки, чтобы дать возможность браузеру пользователя получать разрешения на доступ к выбранным ресурсам с сервера или домена, который отличается от того, что сайт использует в данный момент`,
        i: 'CORS'
    },
    {
        q: `Что такое HTTP?`,
        a: `    HTTP - это прикладной протокол для передачи гипертекстовых документов, по типу HTML
        
    В настоящее время используется для передачи произвольных данных
    
    Создан он в основном для связи между браузерами и серверами
    HTTP - это протокол без сохранения состояния. Т.е. сервер не сохраняет никаких наших данных между парами запрос - ответ`,
        i: 'HTTP'
    },
    {
        q: `Из чего состоит HTTP запрос?`,
        a: `    HTTP запрос содержит следующие элементы:
        
    1. HTTP метод (get, post и т.д.)
    Помогает определить, какой тип операции хочет выполнить пользователь
    
    2. Путь к ресурсу
    
    3. В запросе указывается версия HTTP протокола
    
    4. Еще дополнительно могут быть заголовки, которые отправляют дополнительную информацию на сервер`
    },
    {
        q: `Основные принципы ООП?`,
        a: `    ООП базируется на 4 основных принципах
        
1. абстракция - отделение концепции от реализации
Основная идея в том, чтобы представить объект минимальным набором полей и методов для выполнения поставленной задачи

2. наследование - способность объекта или класса базироваться на другом объекте или классе
При наследовании класса потомок получает все свойства и методы родителя

3. инкапсуляция - размещение одного объекта или класса внутри другого

4. полиморфизм - возможность выполнить задачу разными способами`
    },
    {
        q: `Что такое SOLID?`,
        a: `    Это аббревиатура пяти принципов, которые используются в ООП
    Общая идея в том, что использование нескольких принципов в качестве одного целого лучше, чем использование их по отдельности
    
Принципы SOLID

- принцип одной ответственности

- принцип открытости и закрытости

- принцип подстановки

- принцип разделения интерфейсов

- принцип инверсий и зависимостей`
    },
    {
        q: `Что такое Babel и для чего он используется?`,
        a: `    Babel - это программа - транспайлер, которая переписывает код современного стандарта Java Script на более старый
        
    Транспайлер - это программа, позволяющая менять исходный код одной программы на эквивалентный код на другом языке
    
    Обычно Babel работает на сервере в составе системы сборки js кода, например Web Pack`
    },
    {
        q: `Для чего используется оператор двойного отрицания "!!" ?`,
        a: `    Оператор !! используется для приведения значения, которое находится справа от него к логическому типу
        
    Используя !! с любым типом данных (строка, число, null, объект и т.д.), на выходе мы получаем true или false.
    
    Еще способ привести к логическому значению- использовать Boolean
    
    Boolean('Aleh') // true`
    },
    {
        q: `Как проверить, является ли значение массивом?`,
        a: `    Для этого используется метод Array.isArray([1, 2, 3]) // true`
    },
    {
        q: `Для чего используется оператор "%" ?`,
        a: `    Этим оператором находится остаток от деления одного числа на другое.
        
    Используется для нахождения кратных чисел. Число кратно другому числу, если делится на него без остатка
    
    console.log(5 % 2) // 1`
    },
    {
        q: `Как работает boxing/ unboxing в Java Script?`, 
        a: `    Термины "упаковка" и "распаковка" тесно связаны с понятием обертка
        
    Если у примитивного значения вызвать метод, то примитив временно упаковывается в объект. Например, строка временно упаковывается в объект new String
    
    Этот объект оборачивает примитив и вызывает метод. После исполнения объект уничтожается, а нам возвращается результат работы
    
    Процесс обертки примитива в объект называется "boxing"
    
    Это может идти автоматически. Но также мы можем вызвать этот процесс вручную, когда сами создаем примитив, например, через: 
    
    let str = new String('Maksim');
    
    
    Unboxing - это обратный процесс. Это когда объект преобразовывается в примитив
    
    Также его можно вызвать вручную, используя методы valueOf и toString`,
        i: 'boxing_vs_unboxing'
    },
    {
        q: `Для чего используется цикл "for ... in" ?`,
        a: `    Данный оператор используется для перебора элементов массива.
        
    На каждом проходе создается переменная, значение которой равно значению элемента на каждом проходе
    
    "for ... of" умеет работать с коллекциями по типу map и set`,
        i: 'for_of'
    },
    {
        q: `Что такое шаблонные итералы (Template Literals) ?`,
        a: `    Это новый способ создания строк в Java Script
        
    По-простому - это ото обратные кавычки
    
    Внутри пишем текст, ставим пробелы, где нам нужно, не нужно ставить плюсы. Обязательно если внутри есть кавычки, то они должны отличаться от обратных кавычек, т.е. внутри кавычки либо такого типа '' , либо такого ""`,
        i: 'template_literals'
    },
    {
        q: `ЧТо такое Set, Map и WeackSet ?`,
        a: `    В ES-6 появились новые типы коллекций
        
    Map - это коллекция для хранения записей в виде ключ- значение. В отличие от объектов, у которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например, число или булевое значение
    
    
    Set - это коллекция для хранения множества значений. При этом каждое значение может встречаться только один раз.
    Даже если мы вручную попробуем добавить в Set дубликат, это не сработает
    
    Это можно использовать, например, для решения задачи, когда из массива нужно удалить дубликаты
    
    let arr = [1, 2, 3, 1, 2, 3];
    cosole.log([...Set(arr)]) // [1, 2, 3]
    
    
    WeackMap и WeackSet от оригинальных отличаются только тем, что не препятствуют сборщику мусора удалять свои элементы
    
    Т.е. если некий объект присутствует только в WeackSet или в WeackMap, то он спокойно удаляется уз памяти
    
    WeackSet и WeackMap мы используем только для хранения вспомогательных данных, которые должны существовать только пока существует объект`,
        i: 'set_map_WeackMap_WeackSet'
    },
    {
        q: `Что такое промисы?`,
        a: `    Промисы - это один из способов работы с ассинхронным кодом в JS
        
    Промис  - это объект, который может вернуть одно значение в будущем - либо выполненное значение, либо причину, по которой промис не был выполнен (т.е. ошибку)
    
    Промис может находиться в одном из трех состояний:
    
    1. Выполнено
    
    2. Отклонено
    
    3. Ожидает выполнения
    
    
    При использовании промисов можно добавлять callback функции для обработки выполненного значения или для обработки ошибки
    
    Для этого используется цепочка вызовов с методами then И catch
    
    
    В промис мы передаем функцию, у которой два параметра (resolve И  reject). Внутри этой функции какой-то ассинхронный код
    
    const p = new Promise((resolve, reject)=> {
        setTimeout(()=> {
            console.log('Ответ от сервера');
            resolve();
        }, 2000)
    }).then(()=> {
        return new Promise((resolve, reject)=> {
            setTimeout(()=> {
                console.log('Текст);
            },2000)
        })
    }).then(()=> {
        cosole.log('Text')
    })`,
        i: 'promises'
    },
    {
        q: `Какие методы может иметь HTTP запрос?`,
        a: `    get - запрос на получение данных
        
    post - используется для отправки данных на определенный ресурс
    
    put - заменяет все текущие представления ресурса данными запроса. Используется для редактирования данных
    
    delete - запрос на удаление указанных данных
    
    head - запрашивает аналогично get но без тела ответа
    
    connect - устанавливает тоннель к серверу или определенному ресурсу
    
    patch - частичное изменение ресурса
    
    options - описание параметров соединения с ресурсом`,
        i: 'HTTP_methods'
    },
    {
        q: `Что такое HTTP cookie? Для чего они используются?`,
        a: `    HTTP - это протокол без сохранения состояния, а это значит, что каждая пара запрос - ответ не связана с предыдущей парой запрос - ответ
        
    В реальности это не всегда удобно, т.к. нужно хранить данные, например, аутентификации пользователя или данные, связанные с товаром
    
    Для хранения такой информации используются HTTP cookie. Это небольшой набор данных, которые сервер отправляет на браузер пользователя,  пользователь может их сохранить и отправлять обратно с новым запросом к данному серверу
    
    Cookie может использоваться для: 
    
    - управления сеансом (логин, корзина)
    
    - мониторинга (отслеживания поведения пользователя)
    
    - персонализации (пользовательские предпочтения)`,
        i: 'cookie'
    },
    {
        q: `Разница между feture detection, feature inference и анализом строки user-agent?`,
        a: `    Это подходы для определения браузерных возможностей пользователя
        
    feature detection - определяет, поддерживает ли браузер определенный блок кода. И если блок не поддерживается, о будет выполнен аналог, либо полифил
    
    feature inference -  проверка на наличие определенных возможностей. Применяет функцию, которая предполагает, что определенная возможность уже существует
    
    user-agent - строка, сообщаемая браузером, которая позволяет определить тип приложения, операционную систему, поставщика программного обеспечения и т.д. Доступ к ней можно получить через navigator.userAgent
    
    
    Самый надежный подход feture detection, остальные не рекомендуется использовать`,
        i: 'feature_detection'
    },
    {
        q: `Что такое статический метод класса?`,
        a: `    Статические свойства и методы принадлежат объекту класса и недоступны другим объектам того же класса
        
    Если создать класс, добавить ему статичные свойства и методы через static, потом создать новый объект того же класса и в нем уже обратиться к этим свойствам и методам, то мы получим ошибку
    
    Если мы записали статичное свойство или метод и хотим в этом же объекте обратиться к ним в другом методе, используем ключевое слово this. А в нестатичных методах к статичным обращаются или через имя класса, или через this.constructor.имя статичного`
    },
    {
        q: `Что такое Web компоненты? Какие технологии в них используются?`,
        a: `    Web компоненты - это технология, которая позволяет создавать многократно используемые компоненты в web приложениях

    Они поддерживаются браузерами напрямую и не требуют дополнительных библиотек для работы

    Web компоненты используют 4 технологии, каждая из которых может использоваться отдельно от других
    
    1. custom ivence - API для создания собственных HTML документов

    2. HTML Templace - тег позволяет реализовать изолированные DOM элементы

    3. shadow DOM - изолирует DOM и стили в разных элементах

    4. HTML imports - импорт HTML документов`
    },
    {
        q: `Что такое мемоизация?`,
        a: `    Мемоизация - это прием создания функции, способной запоминать ранее вычисленное значение, а также результат

Т.е. функция вычисляет значение и запоминает его. При повторном вызове, функция сначала проверяет, если это значение уже вычислялось, то функция не будет выполняться, а просто возьмет этот результат из памяти (кэша).
        
К минусам соно отнести то, что для всех полученных элементов нужно выделить дополнительную память

Принцип работы: 

Создается функция, в которой в результате замыкания хранятся данные. И каждый раз, когда функция вызывается, происходит проверка. Если кэш хранит ключ, которому соответствует передаваемый в функцию аргумент, то возвращается сохраненный результат. Если такого ключа нет, то дополнительно при возврате результата в объекте кэш создается новое поле с ключом аргумента и свойством результата

При повторном вызове мемоизированное значение просто вернется из функции`,
        i: "memoize"
    },
    {
        q: `Разница между оператором in и методом hasOwnProperty ?`,
        a: `    Оба подхода предназначены для проверки наличия определенного свойства в объекте
        
    Разница в том, что "in" проверяет наличие свойства не только в самом объекте, но и в его прототипах
    
    А hasOwnProperty проверяте только сам объект`,
        i: 'in_vs_hasOwnProperty'
    },
    {
        q: `Как расшифровывается HTML?`,
        a: `    HTML (от английского HyperText Markup Language) — это язык гипертекстовой разметки страницы. Он используется для того, чтобы дать браузеру понять, как нужно отображать загруженный сайт`
    },
    {
        q: `Какие вы знаете типы HTML тегов?`,
        a: `    Условно теги делятся на следующие типы:

    - теги верхнего уровня;

    Эти теги предназначены для формирования структуры веб-страницы и определяют раздел заголовка и тела документа. 
    Это теги <html>, <head> и <body>



    - теги заголовка документа;

    К этим тегам относятся элементы, которые располагаются в контейнере <head>. Все эти теги напрямую не отображаются в окне браузера, за исключением тега <title>, который определяет название веб-страницы.
    Это теги <title> и <meta>



    - блочные элементы;

    Блочные элементы характеризуются тем, что занимают всю доступную ширину, высота элемента определяется его содержимым, и он всегда начинается с новой строки.

    <blockquote>
    ыровненный блок с отступами слева и справа (примерно по 40 пикселов), а также с пустым пространством сверху и снизу.

    <div>
    Тег <div> относится к универсальным блочным контейнерам и применяется в тех случаях, где нужны блочные элементы без дополнительных свойств. Также с помощью тега <div> можно выравнивать текст внутри этого контейнера с помощью атрибута align.

    <h1>,...,<h6>
    Эта группа тегов определяет текстовые заголовки разного уровня, которые показывают относительную важность секции, расположенной после заголовка.

    <hr>
    Рисует горизонтальную линию, которая по своему виду зависит от используемых атрибутов. Линия всегда начинается с новой строки, а после нее все элементы отображаются на следующей строке.

    <p>
    Определяет параграф (абзац) текста.

    <pre>
    Задает блок предварительно форматированного текста. Такой текст отображается обычно моноширинным шрифтом и со всеми пробелами между словами. В HTML любое количество пробелов идущих в коде подряд на веб-странице показывается как один. Тег <pre> позволяет обойти эту особенность и отображать текст как требуется разработчику.



    - строчные элементы;

    Строчными называются такие элементы веб-страницы, которые являются непосредственной частью другого элемента, например, текстового абзаца. В основном они используются для изменения вида текста или его логического выделения.

    <a>
    Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь.

    <b>
    Определяет жирное начертание шрифта.

    <big>
    Тег <big> увеличивает размер шрифта на единицу по сравнению с обычным текстом. В HTML размер шрифта измеряется в условных единицах от 1 до 7, средний размер текста, используемый по умолчанию, принят 3. Таким образом, добавление тега <big> увеличивает текст на одну условную единицу.

    <br>
    Тег <br> устанавливает перевод строки в том месте, где этот тег находится. В отличие от тега параграфа <p>, использование тега <br> не добавляет пустой отступ перед строкой.

    <em>
    Тег <em> предназначен для акцентирования текста. Браузеры отображают такой текст курсивным начертанием.

    <i>
    Устанавливает курсивное начертание шрифта.

    <img>
    Тег <img> предназначен для отображения на веб-странице изображений в графическом формате GIF, JPEG или PNG. Если необходимо, то рисунок можно сделать ссылкой на другой файл, поместив тег <img> в контейнер <a>. При этом вокруг изображения отображается рамка, которую можно убрать, добавив атрибут border="0" в тег <img>.

    <small>
    Тег <small> уменьшает размер шрифта на единицу по сравнению с обычным текстом. По своему действию похож на тег <big>, но действует с точностью до наоборот.

    <span>
    Универсальный тег, предназначенный для определения строчного элемента внутри документа.

    <strong>
    Тег <strong> предназначен для акцентирования текста. Браузеры отображают такой текст жирным начертанием.

    <sub>
    Отображает шрифт в виде нижнего индекса. Текст при этом располагается ниже базовой линии остальных символов строки и уменьшенного размера — H2O.

    <sup>
    Отображает шрифт в виде верхнего индекса. По своему действию похож на <sub>, но текст отображается выше базовой линии текста — м2.

    Разница между блочными и строчными элементами следующая.

    Строчные элементы могут содержать только данные или другие строчные элементы, а в блочные допустимо вкладывать другие блочные элементы, строчные элементы, а также данные. Иными словами, строчные элементы никак не могут хранить блочные элементы.
    Блочные элементы всегда начинаются с новой строки, а строчные таким способом не акцентируются.
    Блочные элементы занимают всю доступную ширину, например, окна браузера, а ширина строчных элементов равна их содержимому плюс значения отступов, полей и границ.



    - универсальные элементы;
    Особенность этих тегов состоит в том, что они в зависимости от контекста могут использоваться как блочные или встроенные элементы.

    <del>
    Тег <del> используется для выделения текста, который был удален в новой версии документа. Подобное форматирование позволяет отследить, какие изменения в тексте документа были сделаны. Браузеры обычно помечают текст в контейнере <del> как перечеркнутый.

    <ins>
    Тег <ins> предназначен для акцентирования вновь добавленного текста и обычно применяется наряду с тегом <del>. Браузеры помечают содержимое контейнера <ins> подчеркиванием текста.



    - списки;

    Списком называется взаимосвязанный набор отдельных фраз или предложений, которые начинаются с маркера или цифры. Списки предоставляют возможность упорядочить и систематизировать разные данные и представить их в наглядном и удобном для пользователя виде.

    <ol>
    Тег <ol> устанавливает нумерованный список, т.е. каждый элемент списка начинается с числа или буквы и увеличивается по нарастающей.

    <ul>
    Устанавливает маркированный список, каждый элемент которого начинается с небольшого символа — маркера.

    <li>
    Тег <li> определяет отдельный элемент списка. Внешний тег <ul> или <ol> устанавливает тип списка — маркированный или нумерованный.

    <dd>, <dt>, <dl>
    Тройка элементов предназначена для создания списка определений. Каждый такой список начинается с контейнера <dl>, куда входит тег <dt> создающий термин и тег <dd> задающий определение этого термина. Закрывающий тег </dd> не обязателен, поскольку следующий тег сообщает о завершении предыдущего элемента. Тем не менее, хорошим стилем является закрывать все теги.



    - таблицы;

    Таблица состоит из строк и столбцов ячеек, которые могут содержать текст и рисунки. Обычно таблицы используются для упорядочения и представления табличных данных.

    <table>
    Служит контейнером для элементов, определяющих содержимое таблицы. Любая таблица состоит из строк и ячеек, которые задаются с помощью тегов <tr> и <td>.

    <td>
    Предназначен для создания одной ячейки таблицы. Тег <td> должен размещаться внутри контейнера <tr>, который в свою очередь располагается внутри тега <table>.

    <th>
    Тег <th> предназначен для создания одной ячейки таблицы, которая обозначается как заголовочная. Текст в такой ячейке отображается браузером обычно жирным шрифтом и выравнивается по центру.

    <tr>
    Тег <tr> служит контейнером для создания строки таблицы.



    - фреймы
    
    Фреймы разделяют окно браузера на отдельные области, расположенные вплотную друг к другу. В каждую из таких областей загружается самостоятельная веб-страница определяемая с помощью тега <frame>. С помощью фреймов веб-страница делится на два или более документа, которые обычно содержат навигацию по сайту и его контент. Механизм фреймов позволяет открывать документ в одном фрейме, по ссылке, нажатой в совершенно другом фрейме. Допустимо также использовать вложенную структуру элементов, это позволяет дробить фреймы на мелкие области.

    <frame>
    Тег <frame> определяет свойства отдельного фрейма, на которые делится окно браузера.

    <frameset>
    Тег <frameset> заменяет собой элемент <body> на веб-странице и формирует структуру фреймов.

    <iframe>
    Тег <iframe> создает плавающий фрейм, который находится внутри обычного документа, он позволяет загружать в область заданных размеров любые другие независимые документы.`
    },
    {
        q: `Что такое метатеги и для чего они нужны?`,
        a: `    Мета-теги — часть программного HTML-кода, заключенная между тегом <head>...</head> (заголовок страницы). Эти атрибуты не являются обязательными: они не видны пользователю, но сообщают определенную информацию поисковой системе (описание, заголовок, ключевые слова и т.д.).
               
    Мета теги помогают поисковым роботам понять, о чём ваш сайт. По какому запросу показывать его в выдаче и что конкретно транслировать посетителю в поиске. Конечно, роботы будут скрупулёзно обрабатывать каждую страницу и каждую строку текста на сайте. Но мета теги будут чем-то вроде визитной карточки, на которую робот посмотрит в первую очередь.
    
    Зачем нужен title? Он показывает название страницы. По сути,  на прямой запрос пользователя в поисковике первой же строчкой вылезет именно эта страница
    
    Description является кратким описанием страницы. Он будет показан непосредственно под названием сайта в выдаче, в так называемых сниппетах. Как правило, тег description это блок грамматически связанной, читабельной для пользователя информации длинной до 250 символов. Его цель – дать краткое описание страницы. Зачастую именно это описание и приводит целевых клиентов\пользователей на страницу сайта. Title о многом не скажет, но он нужен роботам. А вот description очень хорошо помогает привлекать на ресурс людей.

    Keywords. Мета тег, который состоит из ключевых слов, встречающихся на странице. Нужен чтобы показать роботам самые важные ключевые слова, т.е. по сути, мы предоставляем данные о семантическом ядре. Это облегчает роботам понимание, куда определить ваш сайт. На какие перекрёстные запросы он должен быть показан в выдаче. И в какой тематической группе транслироваться.`
    },
    {
        q: `Расскажите про списки в HTML`,
        a: `    Списки предоставляют возможность упорядочить и систематизировать разные данные и представить их в наглядном и удобном для пользователя виде.

    Любой список представляет собой контейнер <ul>, который устанавливает маркированный список, или <ol>, определяющий список нумерованный. Каждый элемент списка должен начинаться с тега <li>.
    
    - маркированный список
    
    Маркированный список определяется тем, что перед каждым элементом списка добавляется небольшой маркер, обычно в виде закрашенного кружка. Сам список формируется с помощью контейнера <ul>, а каждый пункт списка начинается с тега <li>, как показано ниже.

    <ul>
    <li>Первый пункт</li>
    <li>Второй пункт</li>
    <li>Третий пункт</li>
    </ul>
    В списке непременно должен присутствовать закрывающий тег </ul>, иначе возникнет ошибка.

    Маркеры могут принимать один из трех видов: круг (по умолчанию), окружность и квадрат. Для выбора стиля маркера используется атрибут type тега <ul>
    
    
    - нумерованный список
    
    Нумерованные списки представляют собой набор элементов с их порядковыми номерами. Вид и тип нумерации зависит от атрибутов тега <ol>, который и применяется для создания списка. Каждый пункт нумерованного списка обозначается тегом <li>, как показано ниже.

    <ol>
    <li>Первый пункт</li>
    <li>Второй пункт</li>
    <li>Третий пункт</li>
    </ol>
    Если не указывать никаких дополнительных атрибутов и просто написать тег <ol>, то по умолчанию применяется список с арабскими числами (1, 2, 3,...)
    
    В качестве нумерующих элементов могут выступать следующие значения:

    арабские числа (1, 2, 3, ...);
    прописные латинские буквы (A, B, C, ...);
    строчные латинские буквы (a, b, c, ...);
    прописные римские числа (I, II, III, ...);
    строчные римские числа (i, ii, iii, ...).
    Для указания типа нумерованного списка применяется атрибут type тега <ol>.
    
    Чтобы начать список с определенного значения, используется атрибут start тега <ol>. При этом не имеет значения, какой тип списка установлен с помощью type, атрибут start одинаково работает и с римскими и с арабскими числами.
    
    
    - список определений
    
    Список определений состоит из двух элементов — термина и его определения. Сам список задается с помощью контейнера <dl>, термин — тегом <dt>, а его определение — с помощью тега <dd>
    
    Список определений хорошо подходит для расшифровки терминов, создания глоссария, словаря, справочника и т.д.`
    },
    {
        q: `Возможны ли комментарии в HTML?`,
        a: `    Комментарий в HTML-коде задаётся так:

    <!-- любой текст -->
    Текст внутри комментария не отображается браузером на странице`
    },
    {
        q: `Что такое Charset?`,
        a: `    Указывает кодировку документа. Атрибут введен в HTML5 и предназначен для сокращения формы тега <meta>, которая задавала кодировку в предыдущих версиях HTML и XHTML
        
    <meta charset="кодировка">`
    },
    {
        q: `Что такое атрибуты в HTML?,`,
        a: `    У элементов HTML есть атрибуты; это дополнительные значения, которые настраивают элементы или регулируют их поведение различным способом, чтобы соответствовать критериям пользователей
        
    Все атрибуты состоят из двух частей — это имя и значение:

    Имя — это свойство, которое Вы хотите установить. Например, элемент абзаца <p>, в примере ниже, содержит атрибут align, который Вы можете использовать для указания выравнивания абзаца на странице.
    Значение — это значение, которое Вы хотите установить для свойства. Значение атрибута всегда помещается в кавычки. В приведенном ниже примере показаны три возможных значения атрибута align: left, center и right.
    Имена и значения атрибутов в HTML не зависят от регистра. Однако консорциум World Wide Web (W3C) рекомендует в своей рекомендации HTML 4 использовать атрибуты и значения атрибутов в нижнем регистре.
    
    Основные атрибуты HTML

    Общие атрибуты
    
    align - Горизонтальное выравнивание тегов.

    valign - Вертикальное выравнивание тегов внутри html-элемента.
    
    bgcolor - Помещает фоновый цвет за элемент

    background - Помещает фоновое изображение за элемент
    
    id - Именование элемента для использования с каскадными таблицами стилей
    
    class - Классифицирует элемент для использования с каскадными таблицами стилей
    
    width - Задает ширину таблиц, изображений или ячеек таблицы
    
    height - Задает высоту таблиц, изображений или ячеек таблицы
    
    title - «Всплывающий» заголовок элементов

    Существует четыре основных атрибута в HTML, которые могут использоваться для большинства html-элементов (хотя и не для всех):

    id
    title
    class
    style
    Атрибут id
    Атрибут id html-тега может быть использован для однозначной идентификации любого элемента внутри html-страницы. Существуют две основные причины, по которым Вы можете использовать атрибут id для элемента:

    Если элемент содержит атрибут id как уникальный идентификатор, то можно идентифицировать только этот элемент и его содержимое.
    Если на веб-странице (или в таблице стилей) есть два элемента с одним и тем же именем, Вы можете использовать атрибут id для различения элементов, имеющих одно и то же имя.
    Таблицу стилей мы обсудим в отдельном самоучителе. Пока же давайте использовать атрибут id для различения двух элементов абзаца, как показано ниже.

    <p id="html">Этот абзац объясняет, что такое HTML.</p>
    <p id="css">Этот абзац объясняет, что такое каскадная таблица стилей (CSS).</p>



    Атрибут title
    Атрибут title — дает название элемента для элемента. Синтаксис для атрибута title аналогичен атрибуту id.

    Поведение этого атрибута будет зависеть от элемента, который его несет, хотя он часто отображается как подсказка, когда курсор наводится на элемент или когда элемент загружается.

    Пример

    <!DOCTYPE html>
    <html>
    <head>
        <title>Пример атрибута title</title>
    </head>
    <body>
        <h2 title="Привет самоучитель по HTML!">Пример заголовка</h2>
    </body>
    </html>


    
    Атрибут class
    Атрибут class — используется для связывания элемента со списком стилей и задает класс элементу. Вы узнаете больше об использовании атрибута class, когда изучите CSS (каскадные таблицы стилей). Так что пока можете это пропустить.

    Значением атрибута может быть также список имен классов, разделенных пробелами. Например:

    class="названиеКласса1 названиеКласса2 названиеКласса3"
    
    
    Атрибут style
    Атрибут style — позволяет указывать правила каскадной таблицы стилей (CSS) внутри элемента.

    <!DOCTYPE html>
    <html>
    <head>
        <title>Пример атрибута style</title>
    </head>
    <body>
        <p style="align: center; color: #008cff;">Немного текста... </p>
    </body>
    </html>
    
    
    Атрибуты интернационализации
    Существует три атрибута интернационализации в HTML, которые доступны для большинства (хотя и не для всех) элементов XHTML.

    dir
    lang
    xml:lang


    Атрибут dir
    Атрибут dir — позволяет указать браузеру направление потока текста (слева- направло или справа- налево)
    
    Атрибут lang
    Атрибут lang — позволяет указать основной язык, используемый в документе, но этот атрибут хранится в HTML только для обратной совместимости с более ранними версиями HTML. 
    
    Атрибут xml:lang
    Атрибут xml:lang — это XHTML замена для атрибута lang`
    },
    {
        q: `Что такое Important в CSS?`,
        a: `    Декларация !important - это ключевое слово, которое может быть добавлено в конце любой пары ключ/значение. Например:

    p {margin-left: 5px !important}
    p {margin: 10px 5px 0 10px !important}
    Каково её влияние?
    CSS присваивает вес каждому правилу, в зависимости от его выборки и позиции в исходном элементе. Это определяет стиль HTML-элемента.
    
    Если появляются два конфликтующих правила, то применяется следующий подход для его разрешения:
    
    Источник правила - если одно правило находится в таблице стилей сайта, а второе непосредственно на клиентском компьютере, то применено будет правило клиента.
    Специфика - если два или более правил имеют отношение к одному и тому же свойству, одного и того же элемента, а также один уровень важности и один источник, то будет применено правило более конкретного селектора.
    Порядок - если у двух правил один вес, то будет применено последнее.
    Иногда необходимо поменять приоритет правил. Разорвать цепочку каскада можно с помощью декларации !important. В случае её использования, отмеченное правило будет иметь самый высокий "вес" и именно оно будет использоваться.
    
    В следующем примере, второй селектор является более конкретным и объявлено в конце, но использоваться будет именно первое правило, поскольку в нём используется декларация !important, которое заменяет все остальные правила.
    
    p {margin-left: 5px !important}
    #id p {margin-left: 10px}
        
        Замена inline-стилей
    !important может использоваться для переопределения inline-стилей, которые обычно генерируются WYSIWYG-редакторами в различных CMS.

    Форматирование текста в таких редакторах осуществляется с помощью вставленных напрямую в html-разметку стилей. Эти стили можно переопределить в таблице стилей, используя декларацию !important.

    Например, пользователь хочет вывести текст красным цветом

    <div id="content"><p style="color:red">Some text</p></div>
    Однако автор сайта может переопределить этот стиль, чтобы текст всех параграфов выводился, например, чёрным цветом:

    #content p {color:black !important}
    Стилевые файлы для печати
    Декларация !important также часто используется в таблицах стилей, предназначенных для печати. В этом случае автор сайта уверен, что страница печатается так, как он и предполагал.

    Обратная сторона
    Есть только один способ переопределить стиль отмеченный !important - это использовать более конкретный селектор и также отметить используемый стиль декларацией. Всё это может сделать файл стилей сильно запутанным и сложным для понимания.

    В CSS1 декларация !important автора сайта имела больший приоритет над пользовательским файлом стилей. Это правило изменилось в CSS2, то есть пользователь всегда может переопределить внешний вид сайта.

    Заключение
    Использование декларации !important может сделать файл стилей сложным для понимания и отладки, однако если быть аккуратным, то она поможет вам сохранить время и нервы.`
    }
    
];

searchQuestion();

function searchQuestion() {
    num = Math.floor(Math.random() * arr.length);
    if(arr[num] === null) {
        searchQuestion();
    } else {
        question.innerText = arr[num].q;
        // question.innerText = arr[4].q;
        console.log(arr[num]);

        answerBtn.addEventListener('click', showAnswer);

        nextQuestionBtn.addEventListener('click', next);
    }
    
}

function showAnswer() {
    answer.innerText = arr[num].a;

    if (arr[num].hasOwnProperty('i')) {
        newImg = document.createElement('img');
        newImg.src = `img/${arr[num].i}.jpg`;
        newImg.style.cssText = 'width: 100%; object-fit: contain; margin: 0 auto; padding-top: 10px';
        
        answerBlock.append(newImg);
    }

    arr[num] = null;
}

function next() {
    arr[num] = null;
    if (answerBlock.children.length > 1) {
    answerBlock.removeChild(newImg);
    }
    answer.innerText = '';

    let flag = arr.every(elem => {
        return elem === null;
    });

    if (flag) {
        clear();
    } else {
        searchQuestion();
    }
}

function clear() {
    question.innerText = 'Вы прошли все вопросы';
    answer.innerText = '';

    answerBtn.removeEventListener('click', showAnswer);
    nextQuestionBtn.removeEventListener('click', next);
}

