let question = document.querySelector('.pre_q');
let answer = document.querySelector('.pre_a');
let answerBtn = document.querySelector('.answer_btn');
let nextQuestionBtn = document.querySelector('.quest_btn');
let answerBlock = document.querySelector('.answer');
let num= 0;
let newImg;


let arr = [
    {
        q: 'Что такое Doctype? Для чего он используется?',
        a: `    Doctype используется для указания типа документа. Он добавляется первой строкой любого HTML документа.

    Служит для того, чтобы браузер мог понять, как ему интерпретировать страницу и в соответствии с каким стандартом парсить страницу`
    },
    {
        q: 'Базовая структура HTML страницы?',
        a: `    Первой строкой обязательно указывается Doctype

    <!DOCTYPE html>

    Затем тег <HTML> - контейнер, в котором содержится все содержимое страницы

    <html lang = 'en'>
    
    Далее тег <head>. Он содержит в себе все необходимые данные о HTML странице (заголовок, описание, SEO информация, подключение стилей,шрифтов)

    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    
    Далее <body>- Содержит в себе всю разметку HTML страницы. Здесь вся видимая часть страницы

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    <body>
    </body>
    </hed>
    </html>`
    },
    {
        q: `Что такое семантика? Какие семантические теги вы знаете?`,
        a: `    Семантика в HTML - это использование правильных тегов, которые описывают содержание контента внутри себя.
        
    Семантичный тег - это тег, который обладает каким-то пояснением своего предназначения.
    
    По тегу должно быть понятно, что внутри него находится.
    
    <header></header> - Шапка сайта

    <footer></footer> - подвал

    <aside></aside> - боковая панель

    <nav></nav> - навигация по сайту

    <main></main> - основное содержимое документа

    <p></p> - параграф

    <h1></h1> - заголовок

    <em></em> - курсив с семантикой

    <strong></strong> - жирный текст с семантикой

    <ul></ul> - маркированный список и т.д.`
    },
    {
        q: `Какая разница между тегами <strong>, <em> и <b>, <i>`,
        a: `    <strong> и <em> предназначены для придания элементу логического выделения.
        
    При чтении страницы поисковыми роботами или screen- ридарами на этих элементах будет сделан акцент`
    },
    {
        q: `Разница между call, apply и bind?`,
        a: `    Из-за запутанности кода может случиться ситуация, когда контекст this будет ссылаться не на тот объект, что нам нужен.
    
    Мы можем сами задать, на какой объект будет ссылаться this в определенной функции.
    
    function showName(firstName, lastName) {
        console.log(firstName + ' ' + lastName)
    }
    
    const user = {
        firstName: 'Ivan',
        lastName: 'Petrov'
    }
    
    Теперь указываем, для функции showName, что this внутри нее должен ссылаться на объект user.
    
    Для этого есть 3 способа:
    
    call
    
    showName.call(user, 'firstName', 'lastName) - функция showName сразу же вызовется и отработает
    
    apply

    showName.apply(user, ['firstName', 'lastName]) - функция showName сразу же вызовется и отработает

    В call параметры функции записываются через запятые, их может быть сколько угодно.
    А в apply может быть только два параметра. Поэтому первый параметр - это всегда объект, а остальные параметры просто записываются внутри массива.

    bind

    showName.bind(user, 'firstName', 'lastName)()

    Параметры также как и в call записываются через запятую. Но bind не вызывается сразу. Т.е. мы можем передать контекст, а функцию уже вызвать тогда, когда нам это нужно. Либо, если нужно сразу вызвать, то в конце указываем скобки ()`,
    i: 'apply'
    },
    {
        q: 'Что такое делигирование событий?',
        a: `    Делигирование - это прием разработки, когда вместо того, чтобы вешать кучу однотипных обработчиков событий на все элементы, можно добавить всего лишь один обработчик на общего родителя.

    Например: мы создаем таблицу и нам нужно, чтобы при нажатии на ячейку она закрашивалась в какой-либо цвет. Мы не вешаем обработчики на каждую ячейку (ячеек может быть и тысячи, тогда нам понадобятся тысячи обработчиков). Мы вешаем всего один обработчик на саму таблицу. 

    Далее мы просто указываем, что если элемента, по которому мы кликнули - это ячейка, то она должна закраситься нужным цветом`,
    i: 'delegation'
    },
    {
        q: `Что такое CSS и для чего он используется?`,
        a: `    CSS - расшифровывается как каскадная таблица стилей. Предназначена она для добавления различных стилей на HTML страницу.
        
    На CSS лежит задача добавления на страницу различных визуальных эффектов.
    
    Каскадная- означает, что мы можем подключать стили одновременно несколькими способами и все они будут работать.
    
    Наследование в CSS - означает, что если не указано иное, то конкретный стиль будет унаследован всеми такими же элементами, а также стиль будет применятся ко всем дочерним элементам. 
    
    Например, если мы добавим background-color к div, то все div на страницы изменят цвет и все вложенные элементы в этих div-ах также изменят цвет`
    },
    {
        q: `Варианты добавления CSS стилей на страницу?`,
        a: `    Есть 4 способа: 

    1. <div style="background-color: red></div>
    
    Добавляем стиль конкретному элементу прямо в его теге
    
    2. <head>
            <style>
                div {background-color: red}
            </style>
        </head>
        
    Добавляем стиль в тег <head> к определенным элементам
    
    3. <head>
            <link rel="stylesheet" href="css/style.css">
        </head>
        
    Прикрепляем CSS- файл
    
    4. @import "style/media.css"
        @import "style/footer.css"
       
    Импорты внутри файлов стилей`
    },
    {
        q: `Типы позиционирования в CSS`,
        a: `    Существует 5 типов позиционирования в CSS
        
    1. Static - устанавливается элементам по умолчанию
    
    2. Relative - элемент позиционируется относительно своего текущего положения
    
    3. Absolute - позиционирование относительно другого элемента, у которого позиционирование не Static.
       Если такого элемента нет, то относительно окна браузера

    4. Fixed - позиционирование только относительно окна браузера
    
    5. Sticky - в видимой части экрана элемент ведет себя как fixed. При дальнейшей прокрутке скроллится вместе с родителем`
    },
    {
        q: `Блочная модель CSS?`,
        a: `    Блочная модель позволяет посчитать, какое итоговое пространство будет занимать элемент на странице.
    
    В нее входит:
    
    - сам контент
    
    - padding
    
    - border
    
    - margin
    
    Общий размер элемента- это сумма этих размеров.
    
    Если нам нужно, чтобы размер элемента являлся заданному значению, то используем команду:
    
    box-sizing: border-box
    `,
    i: 'block_model_css'
    },
    {
        q: `Типы данных в CSS?`,
        a: `    В Java Script существует 8 типов данных
        
    1. String
    
    2. Number
    
    3. Bigint
    
    4. Boolean
    
    5. Symbol
    
    6. Object
    
    7. Null
    
    8. Undefined`
    },
    {
        q: `Строгий режим Strict Mode в Java Script?`,
        a: `    Строгий режим позволяет использовать более строгий вариант JS синтаксиса.
        
    Заменяет исключениями некоторые ошибки, которые интерпретатор JS раньше пропускал.
    Более опасные и не полезные черты JS теперь запрещены или приводят к ошибке
    
    Как подключить?

    1. "use strict"

    2. function func() {
            "use strict"
        }

    Строгий режим будет работать только внутри функции

    3. В ES-6 режим добавляется автоматически`
    },
    {
        q: `Какая разница между function declaration и function expression?`,
        a: `    function declaration

    function sum(a,b) {
        return a + b
    }
    
    function expression
    
    let sum = funcrion(a,b) {
        return a + b
    }
    
    function declaration можно вызывать до ее объявления, а function expression нельзя`
    },
    {
        q: `Что такое валидация? Типы проверок HTML - документа?`,
        a: `    Валидация - это проверка документа специальной программой - валидатором на соответствие установленным web стандартам и на обнаружение существующих ошибок.
    
    Эти стандарты называются спецификациями.
    
    Валидатор сначала определяет тип документа, который указывается с помощью Doctype.
    
    Затем проверяет HTML код на правильность и отсутствие ошибок. При этом проверяется правильность имен тегов и их вложенность.
    
    Проверить валидность можно на сайте:
    
    http://validator.w3.org`
    },
    {
        q: `Какой тег использовать, чтобы сверстать кнопку?`,
        a: `    Сразу нужно уточнить, а какая именно кнопка нужна.
        
    1. <button>Нажми</button> - обычная кнопка
    
    2. Кнопки подтверждения формы
    
    <button type="submit">Отправить</button>
    <input type="submit" value="button>
    
    3. <input type="button"> - устаревающий способ
    
    4. <a href="#">Button</a> - кнопка - ссылка. Дальше придаем стили, чтобы чтилизоват ее под кнопку`
    },
    {
        q: `Что такое инлайновый стиль? Можно ли его переопределить?`,
        a: `    Инлайновый стиль - это стиль, примененный к определенному элементу непосредственно в его теге в HTML.
        
    Переопределить его можно с помощью директивы !importmant
    
    <div style="text-align:center"></div>
    
    Чтобы перезаписать его (переопределить) вешаем !importmant на CSS свойство
    
    <style>
        div{text-align:left !importmant}
    </style>`
    },
    {
        q: `Что такое селектор? Какие селекторы существуют?`,
        a: `    Селектор - это часть CSS правила, которая сообщает браузеру, к какому элементу или элементам web страницы будет применен стиль.
        
    Все селекторы делятся на 2 группы
    
    1. Простые
    
    - .class
    
    - #id
    
    - p (тег)
    
     - * (универсальный селектор. Ставим * и дальше описываются правила (имя, класс и т.д.). Т.е. помогает выбрать абсолютно любой элемент со страницы)
     
     - a[href="text]
     
     2. Составные
     
     - h1, h2, span - перечисляем через запятую
     
     - div p - селектор потомка. Через пробел. Указывать можем всю цепочку вложенности
     
     - li > a - селектор только дочернего элемента
     
     - a:hover - селектор псевдокласса
     
     - li:nth-last-child(2n) - селектор псевдоэлемента`
    },
    {
        q:`Что такое специфичность селектора? Как считать вес селектора?`,
        a: `    Специфичность - это способ, с помощью которого браузер определяет, какие значения CSS свойств будут применены к элементу.
        
    Если на элементе висит сразу несколько свойств, повешенных разными способами, то нужно определить, какое из этих свойств будет применяться`
    },
    {
        q: `Разница между Reset.css и Normalize.css?`,
        a: `    Все HTML элементы обладают дефолтными стилями. И в разных браузерах эти стили разные.
        
    Чтобы во всех браузерах контент выглядел одинаково, перед тем как начинать верстку используют эти два метода.
    
    По сути это CSS файл, который подключается в самом начале документа.
    
    1. Reset - сбрасывает все стили и их нужно прописывать заново
    
    2. Normalize - прописываем стили, которые должны будут применяться везде одинаково`
    },
    {
        q: `Что такое поднятие (hoisting)?`,
        a: `    Hoisting - это механизм подъема функции или переменной в глобальную или функциональную область видимости
        
    Java Script сначала объявляет, а затем инициализирует переменные.
    
    Переменные, объявленные через var и функции function declaration можно использовать еще до объявления их значений.
    
    Если function declaration мы можем объявить хоть в самом конце кода, то с var работает не так.
    
    Hoisting работает с объявлением, но инициализация будет только в момент присваивания значения.
    
    Т.е. объявить-то var мы можем в самом конце кода, но пока мы не передадим ей какое - либо значение, переменная через var при обращении к ней будет выдавать undefined
    
    А переменные, объявленные через let и const при обращении к ним до их объявления будут выводить не undefined а ошибку
    
    console.log(a); // undefined
    var a = 20;`
    },
    {
        q: `Типы таймеров в Java Script?`,
        a: `    Есть 2 типа таймеров
    1. setTimeout() - вызывает переданную функцию один раз через указанный промежуток времени

    2. setInterval - будет вызывать функцию постоянно через указанные промежутки времени
    
    clearTimeout - позволяет остановить setTimeout до его вызова
    
    clearInterval - позволяет остановить setInterval. Перед этим setInterval записываем в переменную и ее передаем параметром в clearInterval`
    },
    {
        q: `Типы списков в HTML?`,
        a: `    Есть 3 типа списков
    1. Маркированный <ul></ul>
    
    2. Нумерованный <ol></ol>
    
    3. Список определений 
    
    <dl>
        <dt>Определение</dt>
        <dd>Поясняющий текст</dd>
    </dl>`
    },
    {
        q: `Как семантически правильно сверстать картинку с подписью?`,
        a: `    Нужно использовать сначала тег <figure>

    <figure><img><figcaption>Поясняющий текст</figcaption></figure>

    При этом использование этих тегов не отменяет того, что внутри тега <img> нужно указывать alt

    Перед пояснением <figcaption> может идти несколько изображений и тогда пояснение будет одно для них` 
    },
    {
        q: `Разница между display:none и visibility:hidden?`,
        a: `    Оба правила предназначены для того, чтобы скрывать элемент на странице.
        
    display:none - полностью убирает элемент с HTML страницы. Единственное место, где он останется - это DOM дерево
    
    Контент внутри скрытого таким образом блока становится недоступно для поисковых роботов
    
    visibility:hidden - на HTML странице элемент становится не виден, но из основного потока он не вырывается и по прежнему занимает отведенное для него место. А также он остается доступен для поисковых роботов`
    },
    {
        q: `Разница между блочными и строчными (инлайновыми) элементами?`,
        a: `    Основная разница между блочными и строчными элементами в том, что по умолчанию блочный элемент будет занимать всю ширину экрана, а строчный элемент имеет ширину его содержимого.
        
    Поэтому блочные элементы идут друг под другом, а строчные в одну линию.
    
    Также блочным элементам можно задавать размеры (ширину и высоту), а для строчных это не работает.
    
    Блочные элементы воспринимают margin и padding, а для строчных элементов margin сверху и снизу не работает`
    },
    {
        q: `Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?`,
        a: `    Адаптивный дизайн - это по сути несколько версий одного и того же сайта, которые загружаются пользователю в зависимости от устройства, на котором открыт сайт.
    Пользователь заходит на сайт, браузер определяет тип устройства, с которого пользователь зашел и отправляет его на специально разработанную для этого устройства версию сайта.
        
    Responsive - это один и тот же дизайн, который автоматически сжимается в зависимости от ширины экрана`
    },
    {
        q: `Что такое область видимости (scope)?`,
        a: `    Область видимости или scope - это место, откуда мы имеем доступ к переменным или функциям.
    В JS есть 3 типа областей видимости:
    
    1. Глобальная
    
    2. Функциональная - переменные и функции, объявленные внутри функции доступны только внутри это  функции и всем ее вложенностям
    
    3. Блочная - новая область видимости, которая появилась в ES-6 для переменных, объявленных через let и const
    
    Это область видимости, которая находится между фигурными скобками {}, так называемого блока. Это например (if... else, цикл for)
    
    Переменные, объявленные через var, такую область видимости игнорируют. Т.е. если мы внутри if ... else объявим переменную через var, то она просто станет глобальной`
    },
    {
        q: `Разница между var, let и  const`,
        a: `    var - подвержены всплытию. Если мы обратимся к переменной, объявленной через var до присваивания ей значения (до ее инициализации), то получим просто undefined, а у let и const в таком случаем нам выведет ошибку
        
    У let и const область видимости ограничена блоком, т.е. фигурными скобками. У var область видимости ограничена только функцией
    
    Если let и const объявлены внутри фигурных скобок, то они доступны только внутри них и на всех вложенных уровнях
    
    Переменная, объявленная через var такую область видимости игнорирует и может быть видна за ее пределами
    
    const - невозможно переопределить, т.е. нельзя присвоит ей новое значение`
    },
    {
        q: `Что такое функции высшего порядка?`,
        a: `    Функции высшего порядка - это функции, которые возвращают другие функции или же принимают другую функцию в качестве аргумента
        
    Например: 
    
    let higherOrderFunction = (params, callback) => {
        return callback(params)
    }
    
    К ним относятся такие функции (методы) как :
    
    - map;
    
    - filter
    
    - forEach и т.д.`
    },
    {
        q: `Что такое DOM?`,
        a: `    DOM - это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML кода
        
    Если просто, HTML - это текст, а DOM - это набор связанных объектов, которые создает браузер при парсинге этого текста
    
    Каждый объект соответствует каждому тегу и они вложены друг в друга, как и теги в HTML. Вложенность похожа на форму дерева - поэтому называется DOM- дерево`
    },
    {
        q: `Что такое распространение события (event propogation)?`,
        a: `    Распространение события - это механизм, который отрабатывает когда какое-либо событие происходит в документе
        
    События распространяются от объекта window до вызывающего его элемента. При этом событие последовательно затрагивает всех предков целевого документа
    
    Есть 3 основные фазы распространения событий:
    
    1. capture - событие проходит от корня документа по DOM дереву до целевого элемента. Это фаза захвата
    
    2. target - событие достигает целевого элемента. Обычно его называют event target
    
    3. bubbling - всплытие. Событие возвращается обратно до window, параллельно вызывая все события на родительских элементах`
    },
    {
        q: `Что такое HTML и для чего он используется?`,
        a: `    HTML - это язык гипертекстовой разметки, позволяющий составлять форматированный текст
        
    Данный текст интерпретируется браузером. После чего браузер отображает этот текст на экране в виде элементов web- страницы

    По сути это скелет или каркас любой web- страницы, содержащий разметку

    Основная задача - помочь браузеру понять, как отобразить информацию и какого типа информация используется на странице`
    },
    {
        q: `Расскажите о регулярных выражениях`,
        a: `    Регулярные выражения - это шаблоны, которые используются для сопоставления последовательностей символов в строках
        
    Если проще - то для поиска и замены символов в строке
    
    2 способа создания:
    
    - new RegExp('pattern', 'flags')
    
    - /pattern/flags
    
    Например ищем букву 'n' в слове
    
    const str = prompt('Введите имя);
    const reg = /n/
    console.log(str.search(reg))
    
    Вызываем метод search у той строки, в которой ищем. В ответе получим номер элемента первого совпадения. Если совпадений нет, то получим -1
    
    Чтобы искать не просто первое совпадение, а различные варианты, используются флаги
    
    i - ищем без учета регистра
    
    g - ищем все совпадения, а не только первое
    
    m - если строка идет в несколько строк
    
    Метод search не работает с флагом 'g', потому что сам по себе находит только первое совпадение
    
    
    Метод match - возвращает массив, в котором указывается паттерн, индекс, строка, в которой искали. А если будет стоять флаг g, и будет несколько совпадений, то нам вернется массив, в котором будет буква, которую мы ищем, столько раз, сколько раз ее найдет
    
    console.log('java script'.match(/a/g)) // ['a','a']
    
    
    Метод replace - заменяет найденный элемент на другой указанный элемент

    Например заменим все буквы 'a' на '*'
    let str = 'java script';
    console.log(str.replace(/a/g, '*) // 'j*v* script'
    
    
    
    Фишка - если в replace написать /./, то точка - это любой символ. 
    Например 

    let pas = prompt('Введите пароль')
    console.log(pas.replase(/./g, '*')) // все символы заменятся на звездочки
    
    
    А если нужно найти именно точку, то экранируем ее с помощью обратного слэша \
    
    сonsole.log(str.replace(/\.g, '*')) // заменит все точки на звездочки
    
    Также ищем символ слэша /, и другие символы
    
    
    Метод test - возвращает true или false, если найдет или не найдет совпадение/
    Тут немного другой синтаксис: сначала указываем, что ищем, потом, где ищем
    
    let str = 'jsvs script';
    console.log(/a/ig.test(str)) // true, т.к. есть символ 'a'
    
    
    В регулярных выражениях есть специальные классы
    
    /\d/ - ищет все цифры
    /\w/ - ищет все буквы
    /\s/ - ищет все пробелы
    
    console.log(str.match(/\d/g)) // вернет массив с цифрами
    
    Классы можно комбинировать
    
    let str = 'My name is R2D2
    console.log(str.match(/\w\d\w\d/i))
    
    ищем связку буква- цифра- буква- цифра
    
    
    Обратные классы - когда наоборот нужно найти не цифры, не буквы, не пробелы

    Тоже самое, только используем большие буквы

    /\D/ - ищем не цифры
    /\W/ - ищем не буквы
    /\S/ -ищем не пробелы

    Не забываем ставит флаг 'g'

    Допустим задача, нам приходит ширина элемента 200px, нам нужно ее изменить, т.е. нам нужна только цифра 200

    let width = 200px;
    let numWidth = width.replace(/\D/g, '')

    Находим все, что не цифры и заменяем их на пустую строку, остаются только цифры`
    },
    {
        q: `Что такое элемент canvas и для чего он используется?`,
        a: `    canvas или "холст" - это HTML-5 элемент, который можно использовать для вставки изображений, градиентов и сложной анимации
        
    Также он создает область, в которой с помощью js можно рисовать различные объекты`
    },
    {
        q: `Что такое CSS правило?`,
        a: `    CSS- правило, т.е. базовый синтаксис
    Оно состоит из двух основных составляющих
    - селектор
    - свойства, которые будут к нему применятся
    
    Например
    div{
        background-color: blue;
    }`
    },
    {
        q: `Разница между классом и идентификатором в CSS?`,
        a: `    Для добавления стилей лучше всего использовать класс, а для добавления логики через js использовать идентификатор id
        
    У id больший вес. Он может использоваться на странице только один раз, т.е. не может быть несколько элементов с одним id
    
    Class можно вешать на несколько элементов. У одного элемента может быть несколько классов`,
    i: 'id_vs_class'
    },
    {
        q: `Что такое CSS спрайт и для чего он нужен?`,
        a: `    CSS спрайт - это картинка, которая объединяет несколько изображений в одно большое
    
    Грубо говоря, на одной картинке нарисованы несколько иконок, которые используются на сайте
    
    Чтобы не грузить много изображений, не обращаться за этим постоянно к серверу, рисуют их на одной картинке, она загружается, а потом с помощью css указывается, где какая часть этой большой картинки используется, т.е. какая иконка будет видна
    
    Плюс в том, что опять же к серверу обращаемся только один раз, второе это выполнение предзагрузки пока еще невидимого контента. Иконка, которая появляется при наведении будет уже загружена заранее. В результате не будет видно мигания при смене картинок`
    },
    {
        q: `Как превратить любой тип данных в булевый? Перечислите ложные значения в js`,
        a: `    Чтобы любой тип данных перевести в true или false можно использовать два подхода
    
    1. Boolean() - внутрь передаем данные и получаем true или  false
    
    2. использовать оператор двойного отрицания !!
    
    В JS есть 6 основных элементов, которые возвращают false
    
    - '' пустая строка
    - 0 ноль
    - null
    - undefined
    - NaN
    - false`,
        i:'double_!!'
    },
    {
        q: `Методы строк в Java Script`,
        a: `    Основные
    
    - length 
    
    - charAt(1) - вернет второй символ
    
    - toUpperCase
    
    - toLowerCase
    
    - indexOf('a') - верне номер элемента, который совпадает с a, или -1, если совпадений нет
    
    - lastIndexOf('a') - вернет номер последнего совпадения
    
    - slice - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substring - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substr - второй параметр - сколько символов обрезать
    
    - replace('a', 'b') - найдет символ 'a' И заменит его на 'b'
    
    - split - разбивает в массив
    
    - includes('a') - вернет true, если в строке есть символ 'a'
    
    - startWidth('a') - вернет true, если строка начинается с 'a', 
    
    - endsWidth('a') - вернет true, если строка заканчивается с 'a'`
    },
    {
        q: `Методы массивов в JS`,
        a: `    Основные
        
    - length
    
    - push - добавить элемент в конец массива
    
    - unshift - добавить элемент в начало
    
    - pop - удалить последний элемент
    
    - shift - удалить первый элемент
    
    - splice - изменяет исходный массив! Удаляет и добавляет новые элементы в массив.
    Первый параметр - номер элемента, который удаляем. Второй параметр - сколько элементов удаляем. Третий - что вставляем вместо них
    
    - slice - не изменяет исходный массив! копирует значения в новый
    
    - join
    
    - toString - также переводит массив в строку
    
    - concat - несколько массивов объединяет в один
    
    - forEach - ничего не возвращает, просто проходит циклом
    
    - map - возвращает новый массив, изменяет элементы
    
    - reduce - запоминает промежуточный результат
    
    - filter - возвращает новый массив с элементами, которые соответствуют условию
    
    - sort - сортирует в в лексическом порядке
    
    - every - вернет true, если все элементы соответствуют условию
    
    - some - вернет true, если хотя бы один элемент соответствует условию`
    },
    {
        q: `Что такое цикл событий (event loop) и как он работает?`,
        a: `    Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти - стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

    Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.
    
    Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая - движок браузера ждет, когда поступит событие. Если непустая первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.`,
    i: 'event_loop',
    },
    {
        q: `Что такое статический метод класса (static)?`,
    a: `    Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.
    Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
    
    class Repo {
    static getName() {
        return "Repo name is modern-js-cheatsheet"
    }
    }

    // нам не нужно создавать объект класса Repo
    console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"

    let r = new Repo();
    console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией`
    },
    {
        q: `Что такое Set, Map, WeakSet и WeakMap?`,
        a: `    В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.

    Map – коллекция для хранения записей вида ключ - значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:
    
    'use strict';

    let map = new Map();

    map.set('1', 'str1');   // ключ-строка
    map.set(1, 'num1');     // число
    map.set(true, 'bool1'); // булевое значение

    // в обычном объекте это было бы одно и то же,
    // map сохраняет тип ключа
    alert( map.get(1)   ); // 'num1'
    alert( map.get('1') ); // 'str1'

    alert( map.size ); // 3
    
    
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
    
    'use strict';

    let set = new Set();

    let vasya = {name: "Вася"};
    let petya = {name: "Петя"};
    let dasha = {name: "Даша"};

    // посещения, некоторые пользователи заходят много раз
    set.add(vasya);
    set.add(petya);
    set.add(dasha);
    set.add(vasya);
    set.add(petya);

    // set сохраняет только уникальные значения
    alert( set.size ); // 3

    set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
    
    
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например, обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:
    
    // текущие активные пользователи
    let activeUsers = [
    {name: "Вася"},
    {name: "Петя"},
    {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент`
    },
    {
        q: `Какие методы жизненного цикла компонента существуют в React?`,
        a: `    render() — единственный обязательный метод в классовом компоненте.
    При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null
    
    constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
    Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
    Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().
    
    componentDidMount() - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
    Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
    
    componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
    
    componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    
    shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
    
    static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
    Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.
    
    getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
    
    static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().
    
    componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.`,
    i: 'react_metods_life_cicle'
    },
    {
        q: `Что такое Context в React и для чего он используется?`,
        a: `    Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).

    Контекст позволяет избежать передачи пропсов в промежуточные компоненты:
    
    // Контекст позволяет передавать значение глубоко
    // в дерево компонентов без явной передачи пропсов
    // на каждом уровне. Создадим контекст для текущей
    // UI-темы (со значением "light" по умолчанию).
    const ThemeContext = React.createContext('light');
    
    class App extends React.Component {
        render() {
        // Компонент Provider используется для передачи текущей
        // UI-темы вниз по дереву. Любой компонент может использовать
        // этот контекст и не важно, как глубоко он находится.
        // В этом примере мы передаём "dark" в качестве значения контекста.
        return (
            <ThemeContext.Provider value="dark">
            <Toolbar />
            </ThemeContext.Provider>
        );
        }
    }
    
    // Компонент, который находится в середине,
    // теперь не должен явно передавать UI-тему вниз.
    function Toolbar(props) {
        return (
        <div>
            <ThemedButton />
        </div>
        );
    }
    
    class ThemedButton extends React.Component {
        // Определяем contextType, чтобы получить значение контекста.
        // React найдёт (выше по дереву) ближайший Provider-компонент,
        // предоставляющий этот контекст, и использует его значение.
        // В этом примере значение UI-темы будет "dark".
        static contextType = ThemeContext;
        render() {
        return <Button theme={this.context} />;
        }
    }
    Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.
    
    API:
    React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
    Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.
    Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.
    Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext().`
    },
    {
        q: `Что такое Виртуальная DOM?`,
    a: `    Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

    Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.`
    },
    {
        q: `Для чего нужен атрибут key при рендере списков?`,
    a: `    Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.`
    },
    {
        q: `Как работает проп children?`,
    a: `    Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:

    function FancyBorder(props) {
        return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
            {props.children}
        </div>
        );
    }
    Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
    
    function WelcomeDialog() {
        return (
        <FancyBorder color="blue">
            <h1 className="Dialog-title">
            Добро пожаловать
            </h1>
            <p className="Dialog-message">
            Спасибо, что посетили наш космический корабль!
            </p>
        </FancyBorder>
        );
    }
    Всё, что находится внутри JSX-тега , передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.`
    },
    {
        q: `В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?`,
        a: `    В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().

    В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:

    handleChange(event) {
        this.setState({value: event.target.value.toUpperCase()});
    }
    Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.

    class NameForm extends React.Component {
        constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.input = React.createRef();
        }

        handleSubmit(event) {
        alert('Отправленное имя: ' + this.input.current.value);
        event.preventDefault();
        }

        render() {
        return (
            <form onSubmit={this.handleSubmit}>
            <label>
                Имя:
                <input type="text" ref={this.input} />
            </label>
            <input type="submit" value="Отправить" />
            </form>
        );
        }
    }
    Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.`
    },
    {
        q: `Что такое PureComponent?`,
        a: `    React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.

    Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.
    
    Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние`
    },
    {
        q: `Что такое Компонент высшего порядка (Higher-Order Component, HOC)?`,
    a: `    Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.

    const EnhancedComponent = higherOrderComponent(WrappedComponent);
    Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:
    
    const CommentListWithSubscription = withSubscription(
        CommentList,
        (DataSource) => DataSource.getComments()
    );
    
    const BlogPostWithSubscription = withSubscription(
        BlogPost,
        (DataSource, props) => DataSource.getBlogPost(props.id)
    );
    Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.
    
    Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.`
    },
    {
        q: `Что такое порталы в React?`,
    a: `    Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

    ReactDOM.createPortal(child, container)
    Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
    
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.`
    },
    {
        q: `Что такое React Reconciliation (Cверка) и как он работает?`,
        a: `    Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.

    При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.
    
    Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля.
    
    При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
    
    По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.`
    },
    {
        q: `Можно создавать анимации в React?`,
        a: `    React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.`
    },
    {
        q: `Что выведет на экран следующий код?`,
        a: `    function b(x, y, a) {
                arguments[2] = 10;
                alert(a);
                }
                b(1, 2, 3);
     

    Ответ: 10

    Пояснение: В функции b 3 аргумента, индексы которых начинаются с [0]. Таким образом, аргумент с индексом [2]  — это a. В первой строке функции третьему аргументу функции присваивается значение 10.`
        
    },
    {
        q: `Что выведет в консоль следующий код?`,
        a: `    console.log(false == undefined);
    console.log(false == null);
    console.log(null == undefined);
    
    
    
    
    
    
    Ответ: false false true

    Пояснение: == сравнивает на равенство и не проверяет идентичность типов, поэтому в третьей строке кода в консоль будет выведено значение true.`
    },
    {
        q: `Что выведет в консоль следующий код?`,
        a: `    const numbers = [1, 2, 3, 4, 5];
    const [y] = numbers;
    console.log(y);
    
    
    
    
    
    
    
    
    
    
    
    Ответ: 1

    Пояснение: В данном примере выполнена деструктуризация. По умолчанию переменной у присваивается значение первого элемента массива.`
    },
    
    {
        q: `Что выведет в консоль этот код?`,
        a: `    let x = 3;
    function fn() {
        x = 10;
        return;
        function x() {}
    }
    
    fn();
    console.log(x);
    
    
    
    
    
    
    
    
    
    
    
    Ответ:  3

    Пояснение:  х объявлена как функция, поэтому в итоге она перезаписалась с 10 на 3.`
    },
    {
        q: `Разница между e.preventDefault() и e.stopPropogation()?`,
        a: `    e.preventDefault() - отключает стандартное поведение элемента по умолчанию. Например он отменит переход по ссылке
        
    e.stopPropogation() - отключает распространение события (всплытие или погружение)`
    },
    {
        q: `Методы поиска элементов в DOM?`,
        a: `    -document.getElementById()

    -document.getElementByName()
    
    -document.getElementByTagName()
    
    -document.getElementByClassName()
    
    - querySelector()
    
    - querySelectorAll()`
    },
    {
        q: `Для чего используются Data- атрибуты?`,
        a: `    Использование data - атрибутов - устаревший подход
        
    data - атрибуты используются для хранения различной информации, которую в последующем можно было бы использовать в js для манипуляций
    
    Т.е. прямо в Dom- дереве можо хранить дополнительные данные
    
    Минус в безопасности, т.к. элемент можно изменить в консоли разработчика
    
    С появлением react, angular, vue от data- атрибутов стали отказываться

    
    <ul>
        <li data-price="40" data-weight="45>Pizza</li>
    </ul>
    
    
    Записывается как data- тире и любое название
    
    В CSS обращаемся как li[data-price=40]
    
    В js 

    let li = document.getElementByTagName('li');
    console.log(li..dataset.price)// 40`
    },
    {
        q: `Разница между <script>, <script async> и <script defer> ?`,
        a: `    Когда происходит парсинг HTML документа, парсер может наткнуться на тег <script>. В нем хранится Java Script код.
        
    Проблема в том, что когда парсер доходит до этого тега, <script> блокирует дальнейшее чтение документа до момента своего полного исполнения. Именно поэтому <script> принято добавлять в конец HTML документа перед закрывающим тегом </body>
    
    Если тег <script> содержит async, то он извлекается и исполняется параллельно с чтением HTML документа. Обычно async атрибут применяется для скриптов, которые не зависят от других скриптов на странице. Например это какая-нибудь аналитика
    
    defer - в этом случае скрипт будет извлечен при чтении HTML страницы, однако код js выполнится только после полного ее парсинга. Т.е. js код считывается параллельно HTML, но выполняться js код будет только когда вся HTML страница загружена
    
    Если скриптов с defer несколько, то они будут исполняться в том порядке, как они расположены в HTML документе.
    
    Его следует применять, если логика взаимодействует с DOM- элементами и нужно гарантировать, что код JS не начнет выполняться, пока DOM- дерево не загружено полностью
    
    
    Если тег <script> мы создаем в js коде (т.е. создали в js тег <script>, указали ему src и добавили с помощью append его в body) и через js подключаем несколько таких скриптов, то все они будут выполняться как async и не будут ждать друг друга
    
    function(src){
        let script= document.createElement('script);
        script.src = src;
        script.async = false; // убираем асинхронность
        document.body.append(script);
    }`
    },
    {
        q: `Для чего используется элемент datalist?`,
        a: `    datalist - это HTML-5 элемент, который используется для создания списка с автозаполнением при вводе символов
    
    Вешается он на обычный input- элемент
    Пользователь может либо выбрать что-либо из списка, либо ввести свое значение`,
        i: 'datalist'
    
    },
    {
        q: `Что такое вендорные префиксы и для чего они используются?`,
        a: `    Вендорный префикс - это приставка к css свойству, которая обеспечивает поддержку данного свойства браузерами, в которых оно не внедрено на постоянной основе
        
    Т.е. свойство введено в спецификацию CSS, но в конкретном браузере оно может быть еще в разработке или только тестируется
    
    `,
    i: 'vendor_prefixes'
    },
    {
        q: `Где можно посмотреть, как то или иное css свойство поддерживается в разных браузерах?`,
        a: `    Используем сайт can i use`
    },
    {
        q: `Разница между Progressive Enhancement И Graceful Gagradation?`,
        a: `    Это 2 подхода к созданию кроссплатформенных и кроссбраузерных приложений
        
    Progressive Enhancement предлагает поэтапное создание web интерфейсов от простого к сложному
    
    На каждом из этапов создается web интерфейс как улучшенная версия предыдущего
    
    
    Graceful Gagradation наоборот, сначала делаем сложную версию и потом упрощаем все до более ранних версий браузеров или до мобильной версии`
    },
    {
        q: `Что такое псевдоэлементы и для чего они используются?`,
        a: `    Псевдоэлемент - это ключевое слово, которое добавляется на селектор и позволяет стилизовать определенную часть выбранного элемента


    В CSS есть 5 типов псевдоэлементов:
    1. first-letter - изменяется первая буква в тексте

    2. first-line - изменяется первая строка блочного текста
    
    3. after - вставляется нужный контент после выбранного элемента
    
    4. before - вставляется нужный контент до выбранного элемента
    
    5. selection - позволяет применить стили для части элемента, которая была выделена пользователем`,
    i: 'psevdo_elem'
    },
    {
        q: `Что такое чистая функция?`,
        a: `    Чистая функция должна удовлетворять двум условиям
    
    1. В ней не должно быть побочных эффектов
    2. Каждый раз она должна возвращать одинаковый результат, когда в нее передаются одни и те же параметры
    
    Чистая функция не зависит от внешних элементов
    
    let x = 4;
    let add = (y)=> x + y;
    add(4);
    
    Мы будем передавать каждый раз 4, но в зависимости от значения переменной "х" мы получим разный результат. Т.е. эта функция не является чистой `,
    i: 'clean_function'
    },
    {
        q: `Разница между forEach() и map()?`,
        a: `    Эти методы применяются к массивам, чтобы на каждом элементе вызывать callback функцию
        
    Главное отличие в том, что forEach() перебирает массив и ничего не возвращает
    
    map - перебирает массив, формирует и возвращает новый массив. Этот новый массив мы можем присвоить в переменной и использовать дальше. 
    
    Оба метода не изменяют исходный массив, к которому они применяются`,
    i: 'forEach_vs_map'
    },
    {
        q: `Что такое "this" в Java Script?`,
        a: `    This - это контекст вызова, или ссылка на значение объекта, который в данный момент выполняет или вызывает функцию. Т.е. это объект до точки
        
    Контекст можно установить с помощью методов call(), apply() и bind()`,
        i: 'this'
    },
    {
        q: `Почему в js функции называют объектами первого класса?`,
        a: `    Объекты первого класса - это элементы, которые можно передать в функцию, вернуть из функции, присвоить переменным
        
    Собственно, все это можно сделать с функциями. `
    },
    {
        q: `Что такое схлопывание границ (margin collapsing)?`,
        a: `    Схлопывание границ - это механизм взаимодействия отступов по вертикали.
        
    Такой эффект наблюдается у блочных элементов, которые расположены друг под другом. Их отступы не суммируются. Отступ между ними становится равным не сумме их отступов, а равен значению большего из них`,
        i: 'margin_collapsing'
    },
    {
        q: `Что такое кроссбраузерность?`,
        a: `Это корректное отображение сайта в разных браузерах и на разных устройствах
        
    Т.е. созданный сайт должен одинаково выглядеть в разных браузерах
    
    
    Некоторые техники кроссбраузерности:
    
    - сематическая верстка
    - использование Rezet и Normalize
    - добавление вендорных префиксов
    - использование media запросов
    - использование полифилов и ранспиллиров`
    },
    {
        q: `Что такое CSS препроцессор?`,
        a: `    Это программа, которая позволяет генерировать CSS из собственного синтаксиса. Т.е. на выходе она дает сгенерированный CSS код
        
    В препроцессорах есть переменные, вложенность, переиспользуемые куски кода
    
    Синтаксис препроцессора удобнее чем синтаксис CSS
    
    Sass, Less, Stylus - наиболее популярные препроцессоры`
    },
    {
        q: `Как определить, есть ли в объекте такое-то свойство?`,
        a: `    Для того чтобы определить, присутствует ли в объекте указанное свойство, можно воспользоваться одним из трех способов
        
    1. hasOwnProperty() - вернет true или false

    2. console.log('prop1' in obj) - вернет true, если в объекте obj есть свойство prop1
    
    3. console.log(obj[prop1]) - вернет значение свойства prop1, если оно есть, а если его нет, то вернет undefined`
    },
    {
        q: `Что такое замыкание? Объясните принцип его работы`,
        a: `    При создании функции и объявлении внутри этой функции переменной, эта переменная будет видна только внутри этой функции и всем ее вложенностям. Снаружи получить доступ к этой переменной мы не можем
        
    На хранение таких переменных выделяется определенная память и когда функция заканчивает свое выполнение, эта память очищается и эта переменная больше нигде не существует
    
    Но если внутри функции создавать другую функцию, то эта функция получит доступ к нашей переменной, которая была объявлена в родительской функции
    
    Т.е. вложенная функция замыкает на себе переменную и аргументы внешней функции
    
    Чтобы создать замыкание, внешняя функция должна объявить переменную, а затем вернуть через return вложенную функцию
    
    Потом внешнюю функцию передаем в какую либо переменную`,
        i: 'closure'
    },
    {
        q: `Что такое IIFE?`,
        a: `    Это переводится как анонимная самовызывающаяся функция. Она выполняется сразу же после создания`,
        i: 'IIFE'
    },
    {
        q: `Что такое всевдомассив аргументов?`,
        a: `    Arguments - это коллекция аргументов, которая передается в функцию
        
    Т.к. это псевдомассив, то у него работает только метод length
    
    Чтобы превратить псевдомассив в массив можно использовать 
    Array.prototype.slice.call(arguments)

    но проще использовать спред оператор 
    [...arguments]

    В стрелочных функциях псевдомассив arguments недоступен`,
    i: 'arguments'
    },
    {
        q: `Разница между host- объектами и нативными объектами`,
        a: `    Host- Объекты - это объекты, которые предоставляются средой выполнения, т.е. браузером для Front-end Иkb Node.js  для Back-end

    В браузере к ним можно отнести window, document, location, history
    
    Нативные объекты - это объекты, которые являются частью языка js. К ним можно отнести, например, объекты string, object, function`,
        i: "hostObjects_vs_nativeObjects"
    },
    {
        q: `Разница между event.target и event.currentTarget?`,
        a: `    event.target - это элемент, в котором происходит событие, или элемент, вызвавший событие
        
    event.currentTarget - это непосредственно элемент, к которому прикрепляем прослушиватель события
    
    Например, у нас есть <div>, а внутри div находится кнопка button. Мы вешаем обработчик события на div
    
    Дальше мы кликаем не на div а на кнопку
    
    event.target - выдаст нам button
    
    event.currentTarget - выжаст нам div, т.к. обработчик висит на нем`,
    },
    {
        q: `Разница между stopPropogation() и stopmediatePropogation()?`,
        a: `    При наступлении события в браузере происходит всплытие. В результате обработчики вызываются сначала на самом вложенном элементе и дальше вызываются обработчики всех родителей элемента по цепочке
        
    stopPropogation() и stopmediatePropogation() служат для остановки всплытия, чтобы не срабатывали все обработчики
    
    
    stopPropogation() отменяет дальнейшее всплытие, но на текущем элементе все обработчики срабатывают
    
    stopmediatePropogation() - отменяет дальнейшее всплытие и на текущем элементе обработчики не сработают тоже`,
    i: 'stopPropogation_vs_stopImediatePropogation'
    },
    {
        q: `Разница между событиями Load и  DOMContentLoad?`,
        a: `    Оба события срабатывают при загрузке страницы в браузере
        
    Разница между ними в том, что:

    DOMContentLoad отрабатывает, когда браузер полностью загрузил HTML, после чего было построено DOM- дерево, однако внешние ресурсы, по типу стилей, скриптов, картинок еще не прогружены
    
    load - это событие, когда браузер загрузил HTML и все зависимые внешние ресурсы (шрифты, стили, картинки и т.д.)
    
    Т.е. DOMContentLoad всегда сработает раньше чем load`,
    i: 'load_vs_DomContentLoad'
    },
    {
        q: `Разница между синхронными и асинхронными функциями?`,
        a: `    Синхронные функции являются блокирующими, а асинхронные нет
        
    Во время выполнения js кода, когда интерпретатор натыкается на синхронную функцию, он блокирует дальнейшее выполнение операций пока данная функция не будет выполнена
    Такие функции выполняются последовательно, одна за одной
    
    Асинхронные функции не блокируют дальнейшее выполнение скрипта
    Обычно такие функции в качестве аргумента принимают callback функцию, которая будет выполнена после того, как выполнится ассинхронная`,
    i: 'sync_vs_asyncFunction'
    },
    {
        q: `Что такое прогрессивный рендеринг?`,
        a: `    Это обобщенное название технологий, которые используются для ускорения отрисовки web страниц
        
    Основная идея - это как можно раньше показать пользователю визуальный контент. Основная задача - уменьшение скорости загрузки
    
    К технологиям прогрессивного рендеринга можно отнести:
    
    - ленивую загрузку картинок. Когда на странице загружаются не все картинки, а только те, что находятся в видимой области экрана. Это реализуется с помощью js
    
    - приоритетизация видимого контента. При этом подходе минимизируют и инкапсилируют стили, разметку и скрипты для той части страницы, которую пользователь увидит первой
    
    Для реализации можно использовать события DOMContentLoad и Load, либо как вариант применять асинхронные скрипты
    
    - асинхронные фрагменты HTML`
    },
    {
        q: ' Что выведется в консоли: console.log({} === {}) ?',
        a: `    false, т.к. объекты - это ссылочный тип данных и они ссылаются на разные участки памяти`
    },
    {
        q: `Что такое прототипное наследование? Как создать объект без прототипа?`,
        a: `    Все объекты в Java Script имеют свойство prototype, которое является ссылкой на другой объект
        
    Когда мы обращаемся к какому-либо свойству объекта и в этом объекте такого свойства нет. то механизм js просматривает прототип объекта и ищет это свойство там. Затем он идет в прототип прототипа и т.д.
    
    Чтобы создать объект, у которого нет прототипа, нужно воспользоваться командой
    
    let obj = Object.create(null)`
    },
    {
        q: `Почему расширение нативных Java Script объектов - плохая практика?`,
        a: `    Java Script использует механизм прототипного наследования, а это значит, что если свойство или метод не найде в текущем объекте, то поиск будет осуществляться дальше по прототипам.
        
    Расширение нативного объекта - это значит добавление новых свойств его прототипу
    
    Если мы добавляем новое свойство прототипу, у нас могут возникнуть проблемы. Например, при использовании сторонних библиотек, в них может быть свойство с таким же названием и потом возникнет конфликт или что-то будет работать некорректно`
    },
    {
        q: `Что такое NaN? Как определить, что значение равно NaN?`,
        a: `    NaN - 'not a number' - не число
        
    Это ненастраивоемое свойство глобального объекта. Появляется, когда математическая функция сработала неверно.
    Например parseInt('string') // NaN
    
    NaN Не равно ничему, включая самого себя
    NaN === NaN // false
    NaN == NaN // false
    
    Проверить, является ли значение NaN: isNaN('string') // NaN`
    },
    {
        q: `Что такое ECMAScript? В чем отличие ECMAScript от Java Script?`,
        a: `    ECMAScript - это спецификация, стандарт скриптового языка программирования
        
    Он содержит в себе правила, сведения и рекомендации, которые должны соблюдаться скриптовым языком, чтобы он считался совместимым с ECMAScript
    
    А Java Script - это как раз скриптовый язык программирования, который соответствует спецификации ECMAScript
    
    Самая новая версия ECMAScript - эот ES-6 или ES-2015`
    },
    {
        q: `Можно ли изменить значение, определенное через const?`,
        a: `    Можно изменить только свойства объекта, который присвоен переменной через const. Присвоить другой объект или другое значение в принципе, нельзя`
    },
    {
        q: `Что такое временная мертвая зона(temporal dead zone)?`,
        a: `    На самом деле let и const всплывают точно также как и var.
        
    Но чтобы легче было отлавливать ошибки, которые в ES-5 были вызваны всплыванием переменных, создали temporal dead zone
    
    Т.е. переменные по факту будут созданы, когда интерпретатор зайдет в область их видимости, но они будут недоступны, пока выполнение кода не дойдет до их фактического объявления. И только в этот момент произойдет их выход из временной мертвой зоны и с переменными можно будет работать`
    },
    {
        q: `Что такое AJAX?`,
        a: `    AJAX - ассинхронный Java Script и XML
        
    AJAX - 'это не технология сама по себе, а термин, который описывает подход к использованию нескольких существующих технологий для работы на стороне клиента и для создания ассинхронных web приложений
    
    С помощью AJAX web приложения могут отправлять данные на сервер и получать их с сервера ассинхронно
    
    А также с помощью AJAX страницы могут динамически изменять содержимое без перезагрузки страницы.
    
    На практике вместо формата XML используют формат JSON, т.к. он основан на Java Script`
    },
    {
        q: `Что такое same- otigin polisy в контексте Java Script?`,
        a: `    Это принцип одинакового источника. Определяет, как документ или скрипт, загруженный из данного источника, может взаимодействовать с ресурсом, загруженным из другого источника
        
    Этот принцип не позволяет Java Script выполнять запросы за границы домена. Это позволяет изолировать потенциально вредоносные документы. И не дает вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой`
    },
    {
        q: `Разница между attribute и property у DOM элементов?`,
        a: `    attribute - это значение, которое прописано в HTML. Оно не меняется
        
    Его можно посмотреть с помощью getAttribute(value)
    
    А property (свойство) - это вычисленное значение DOM элемента.
    Его можно менять и работать с ним`,
    i: 'attribute_vs_property'
    },
    {
        q: `Разница между HTMLCollection и NodeList?`,
        a: `    HTMLCollection - это динамическая HTML коллекция, которая представляет собой массивоподобный объект дочерних элементов
        
    NodeList - это список нод
    
    querySelectorAll - возвращает NodeList
    getElementsByClassName - возвращает HTMLCollection
    
    
    Отличие в том, что если в разметку динамически будет добавлен новый элемент, он добавится только в HTMLCollection, потому что это динамическая структура данных, а NodeList - статическая
    
    Т.е. NodeList один раз формируется и больше не изменяется`
    },
    {
        q: `Что такое объектая обертка (wrapper Objacts)?`,
        a: `    В Java Script типы данных - это примитивы и объекты. И у примитивов тоже есть свои методы
        
    Это возможно, как раз благодаря объектной обертке. Дело в том, что во время исполнения кода примитив временно преобразуется в объект
    
    Это аналогично тому, как если бы в момент применения метода использовался бы конструктор newString, например
    
    У каждого примитива, кроме null и undefined есть такой объект обертка
    
    После работы со свойством или методом, временный объект отбрасывается`
    },
    {
        q: `Как в Java Script создать объект?`,
        a: `    Есть 3 основных способаЖ
        
    1. let person = {
        name: 'Aleh'
    }
    
    2. Через функцию конструктор
    
    function Person(name) {
        this.name = name;
    }
    
    let man = new Person('Aleh')
    
    3. let person = Object.create(humans);
    
    person.name = 'Aleh
    
    В Object.create() указывается прототип`,
        i:'newObject'
    },   
    {
        q: `Для чего используется ключевое слово 'new'?`,
        a: `    Используется для создания функции - конструктора.
        
    Ключевое слово 'new' делает 4 вещи:
        
    1. Создает пустой объект
    2. Привязывает к созданному объекту значение this
    3. Каждый объект, созданный функцией, автоматически получает свойство prototype
    4. Возвращает значение this`,
        i: 'new'
    },
    {
        q: `Разница между Rest и  Spred операторами?`,
        a: `    Они имеют одинаковый синтаксис, но выполняют противоположные задачи
        
    Spred оператор используется для разделения коллекций на отдельные элементы
    
    Rest - наоборот, собирает отдельные значения в массив`,
        i: 'rest_vs_spred'
    },{
        q: `Что такое деструктуризация?`,
        a: `    Деструктуризация - это способ извлекать значения из объектов и массивов и помещать их в отдельные переменные
        
    Вместо того, чтобы каждый раз объявлять новые переменные и присваивать им значения из массива или объекта, переменные записываются в квадратных или фигурных скобках, дальше пишется равно и указывается объект или массив, деструктуризация данных которого должна произойти`,
        i: 'destructuring'
    },
    {
        q: `Что такое цикл событий (event loop) и как он работает?`,
        a: `    Движок в Java Script в одну единицу времени может выполнять только одну операцию. Для такого потока выделяется область памяти, которая называется стек.
        
    События, которые должны будут отработаться попадают в очередь событий. Когда стек освобождается, туда должно попасть следующее событие из очереди. Чтобы определить, какое именно событие из очереди попадет следующим в стек для выполнения, нужен event loop
    
    По сути - это бесконечный цикл, в котором выполняются многочисленные обработчики событий
    
    Если очередь пустая, то браузер ждет, когда поступит новое событие в очередь, а затем в стек
    
    Если очередь не пустая, то берется первое событие из очереди, закидывается в стек и начинает выполняться, а в event loop снова цикл проходит, вычисляя, какое событие пойдет отрабатываться следующим`,
       i:'eventLoop'
    },
    {
        q: `Что такое CORS?`,
        a: `    В целях безопасности браузеры ограничивают кроссдоменные запросы, которые создаются скриптами
        
    Т.е. XMLHTTPRequest и Fetch следуют политике источника.
    
    Web приложения, которые используют такие API, могут запрашивать ресурсы только с того домена, с которого они были загружены
    
    Этот принцип не позволяет JS выполнять запросы за границы домена
    
    CORS - это механизм, который использует дополнительный HTTP заголовки, чтобы дать возможность браузеру пользователя получать разрешения на доступ к выбранным ресурсам с сервера или домена, который отличается от того, что сайт использует в данный момент`,
        i: 'CORS'
    },
    {
        q: `Что такое HTTP?`,
        a: `    HTTP - это прикладной протокол для передачи гипертекстовых документов, по типу HTML
        
    В настоящее время используется для передачи произвольных данных
    
    Создан он в основном для связи между браузерами и серверами
    HTTP - это протокол без сохранения состояния. Т.е. сервер не сохраняет никаких наших данных между парами запрос - ответ`,
        i: 'HTTP'
    },
    {
        q: `Из чего состоит HTTP запрос?`,
        a: `    HTTP запрос содержит следующие элементы:
        
    1. HTTP метод (get, post и т.д.)
    Помогает определить, какой тип операции хочет выполнить пользователь
    
    2. Путь к ресурсу
    
    3. В запросе указывается версия HTTP протокола
    
    4. Еще дополнительно могут быть заголовки, которые отправляют дополнительную информацию на сервер`
    },
    {
        q: `Основные принципы ООП?`,
        a: `    ООП базируется на 4 основных принципах
        
    1. абстракция - отделение концепции от реализации
    Основная идея в том, чтобы представить объект минимальным набором полей и методов для выполнения поставленной задачи

    2. наследование - способность объекта или класса базироваться на другом объекте или классе
    При наследовании класса потомок получает все свойства и методы родителя

    3. инкапсуляция - размещение одного объекта или класса внутри другого

    4. полиморфизм - возможность выполнить задачу разными способами`
    },
    {
        q: `Что такое SOLID?`,
        a: `    Это аббревиатура пяти принципов, которые используются в ООП
    Общая идея в том, что использование нескольких принципов в качестве одного целого лучше, чем использование их по отдельности
    
    Принципы SOLID

    - принцип одной ответственности

    - принцип открытости и закрытости

    - принцип подстановки

    - принцип разделения интерфейсов

    - принцип инверсий и зависимостей`
    },
    {
        q: `Что такое Babel и для чего он используется?`,
        a: `    Babel - это программа - транспайлер, которая переписывает код современного стандарта Java Script на более старый
        
    Транспайлер - это программа, позволяющая менять исходный код одной программы на эквивалентный код на другом языке
    
    Обычно Babel работает на сервере в составе системы сборки js кода, например Web Pack`
    },
    {
        q: `Для чего используется оператор двойного отрицания "!!" ?`,
        a: `    Оператор !! используется для приведения значения, которое находится справа от него к логическому типу
        
    Используя !! с любым типом данных (строка, число, null, объект и т.д.), на выходе мы получаем true или false.
    
    Еще способ привести к логическому значению- использовать Boolean
    
    Boolean('Aleh') // true`
    },
    {
        q: `Как проверить, является ли значение массивом?`,
        a: `    Для этого используется метод Array.isArray([1, 2, 3]) // true`
    },
    {
        q: `Для чего используется оператор "%" ?`,
        a: `    Этим оператором находится остаток от деления одного числа на другое.
        
    Используется для нахождения кратных чисел. Число кратно другому числу, если делится на него без остатка
    
    console.log(5 % 2) // 1`
    },
    {
        q: `Как работает boxing/ unboxing в Java Script?`, 
        a: `    Термины "упаковка" и "распаковка" тесно связаны с понятием обертка
        
    Если у примитивного значения вызвать метод, то примитив временно упаковывается в объект. Например, строка временно упаковывается в объект new String
    
    Этот объект оборачивает примитив и вызывает метод. После исполнения объект уничтожается, а нам возвращается результат работы
    
    Процесс обертки примитива в объект называется "boxing"
    
    Это может идти автоматически. Но также мы можем вызвать этот процесс вручную, когда сами создаем примитив, например, через: 
    
    let str = new String('Maksim');
    
    
    Unboxing - это обратный процесс. Это когда объект преобразовывается в примитив
    
    Также его можно вызвать вручную, используя методы valueOf и toString`,
        i: 'boxing_vs_unboxing'
    },
    {
        q: `Для чего используется цикл "for ... in" ?`,
        a: `    Данный оператор используется для перебора элементов массива.
        
    На каждом проходе создается переменная, значение которой равно значению элемента на каждом проходе
    
    "for ... of" умеет работать с коллекциями по типу map и set`,
        i: 'for_of'
    },
    {
        q: `Что такое шаблонные итералы (Template Literals) ?`,
        a: `    Это новый способ создания строк в Java Script
        
    По-простому - это ото обратные кавычки
    
    Внутри пишем текст, ставим пробелы, где нам нужно, не нужно ставить плюсы. Обязательно если внутри есть кавычки, то они должны отличаться от обратных кавычек, т.е. внутри кавычки либо такого типа '' , либо такого ""`,
        i: 'template_literals'
    },
    {
        q: `ЧТо такое Set, Map и WeackSet ?`,
        a: `    В ES-6 появились новые типы коллекций
        
    Map - это коллекция для хранения записей в виде ключ- значение. В отличие от объектов, у которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например, число или булевое значение
    
    
    Set - это коллекция для хранения множества значений. При этом каждое значение может встречаться только один раз.
    Даже если мы вручную попробуем добавить в Set дубликат, это не сработает
    
    Это можно использовать, например, для решения задачи, когда из массива нужно удалить дубликаты
    
    let arr = [1, 2, 3, 1, 2, 3];
    cosole.log([...Set(arr)]) // [1, 2, 3]
    
    
    WeackMap и WeackSet от оригинальных отличаются только тем, что не препятствуют сборщику мусора удалять свои элементы
    
    Т.е. если некий объект присутствует только в WeackSet или в WeackMap, то он спокойно удаляется уз памяти
    
    WeackSet и WeackMap мы используем только для хранения вспомогательных данных, которые должны существовать только пока существует объект`,
        i: 'set_map_WeackMap_WeackSet'
    },
    {
        q: `Что такое промисы?`,
        a: `    Промисы - это один из способов работы с ассинхронным кодом в JS
        
    Промис  - это объект, который может вернуть одно значение в будущем - либо выполненное значение, либо причину, по которой промис не был выполнен (т.е. ошибку)
    
    Промис может находиться в одном из трех состояний:
    
    1. Выполнено
    
    2. Отклонено
    
    3. Ожидает выполнения
    
    
    При использовании промисов можно добавлять callback функции для обработки выполненного значения или для обработки ошибки
    
    Для этого используется цепочка вызовов с методами then И catch
    
    
    В промис мы передаем функцию, у которой два параметра (resolve И  reject). Внутри этой функции какой-то ассинхронный код
    
    const p = new Promise((resolve, reject)=> {
        setTimeout(()=> {
            console.log('Ответ от сервера');
            resolve();
        }, 2000)
    }).then(()=> {
        return new Promise((resolve, reject)=> {
            setTimeout(()=> {
                console.log('Текст);
            },2000)
        })
    }).then(()=> {
        cosole.log('Text')
    })`,
        i: 'promises'
    },
    {
        q: `Какие методы может иметь HTTP запрос?`,
        a: `    get - запрос на получение данных
        
    post - используется для отправки данных на определенный ресурс
    
    put - заменяет все текущие представления ресурса данными запроса. Используется для редактирования данных
    
    delete - запрос на удаление указанных данных
    
    head - запрашивает аналогично get но без тела ответа
    
    connect - устанавливает тоннель к серверу или определенному ресурсу
    
    patch - частичное изменение ресурса
    
    options - описание параметров соединения с ресурсом`,
        i: 'HTTP_methods'
    },
    {
        q: `Что такое HTTP cookie? Для чего они используются?`,
        a: `    HTTP - это протокол без сохранения состояния, а это значит, что каждая пара запрос - ответ не связана с предыдущей парой запрос - ответ
        
    В реальности это не всегда удобно, т.к. нужно хранить данные, например, аутентификации пользователя или данные, связанные с товаром
    
    Для хранения такой информации используются HTTP cookie. Это небольшой набор данных, которые сервер отправляет на браузер пользователя,  пользователь может их сохранить и отправлять обратно с новым запросом к данному серверу
    
    Cookie может использоваться для: 
    
    - управления сеансом (логин, корзина)
    
    - мониторинга (отслеживания поведения пользователя)
    
    - персонализации (пользовательские предпочтения)`,
        i: 'cookie'
    },
    {
        q: `Разница между feture detection, feature inference и анализом строки user-agent?`,
        a: `    Это подходы для определения браузерных возможностей пользователя
        
    feature detection - определяет, поддерживает ли браузер определенный блок кода. И если блок не поддерживается, о будет выполнен аналог, либо полифил
    
    feature inference -  проверка на наличие определенных возможностей. Применяет функцию, которая предполагает, что определенная возможность уже существует
    
    user-agent - строка, сообщаемая браузером, которая позволяет определить тип приложения, операционную систему, поставщика программного обеспечения и т.д. Доступ к ней можно получить через navigator.userAgent
    
    
    Самый надежный подход feture detection, остальные не рекомендуется использовать`,
        i: 'feature_detection'
    },
    {
        q: `Что такое статический метод класса?`,
        a: `    Статические свойства и методы принадлежат объекту класса и недоступны другим объектам того же класса
        
    Если создать класс, добавить ему статичные свойства и методы через static, потом создать новый объект того же класса и в нем уже обратиться к этим свойствам и методам, то мы получим ошибку
    
    Если мы записали статичное свойство или метод и хотим в этом же объекте обратиться к ним в другом методе, используем ключевое слово this. А в нестатичных методах к статичным обращаются или через имя класса, или через this.constructor.имя статичного`
    },
    {
        q: `Что такое Web компоненты? Какие технологии в них используются?`,
        a: `    Web компоненты - это технология, которая позволяет создавать многократно используемые компоненты в web приложениях

    Они поддерживаются браузерами напрямую и не требуют дополнительных библиотек для работы

    Web компоненты используют 4 технологии, каждая из которых может использоваться отдельно от других
    
    1. custom ivence - API для создания собственных HTML документов

    2. HTML Templace - тег позволяет реализовать изолированные DOM элементы

    3. shadow DOM - изолирует DOM и стили в разных элементах

    4. HTML imports - импорт HTML документов`
    },
    {
        q: `Что такое мемоизация?`,
        a: `    Мемоизация - это прием создания функции, способной запоминать ранее вычисленное значение, а также результат

    Т.е. функция вычисляет значение и запоминает его. При повторном вызове, функция сначала проверяет, если это значение уже вычислялось, то функция не будет выполняться, а просто возьмет этот результат из памяти (кэша).
            
    К минусам соно отнести то, что для всех полученных элементов нужно выделить дополнительную память

    Принцип работы: 

    Создается функция, в которой в результате замыкания хранятся данные. И каждый раз, когда функция вызывается, происходит проверка. Если кэш хранит ключ, которому соответствует передаваемый в функцию аргумент, то возвращается сохраненный результат. Если такого ключа нет, то дополнительно при возврате результата в объекте кэш создается новое поле с ключом аргумента и свойством результата

    При повторном вызове мемоизированное значение просто вернется из функции`,
        i: "memoize"
    },
    {
        q: `Разница между оператором in и методом hasOwnProperty ?`,
        a: `    Оба подхода предназначены для проверки наличия определенного свойства в объекте
        
    Разница в том, что "in" проверяет наличие свойства не только в самом объекте, но и в его прототипах
    
    А hasOwnProperty проверяте только сам объект`,
        i: 'in_vs_hasOwnProperty'
    },
    {
        q: `Как расшифровывается HTML?`,
        a: `    HTML (от английского HyperText Markup Language) — это язык гипертекстовой разметки страницы. Он используется для того, чтобы дать браузеру понять, как нужно отображать загруженный сайт`
    },
    {
        q: `Какие вы знаете типы HTML тегов?`,
        a: `    Условно теги делятся на следующие типы:

    - теги верхнего уровня;

    Эти теги предназначены для формирования структуры веб-страницы и определяют раздел заголовка и тела документа. 
    Это теги <html>, <head> и <body>



    - теги заголовка документа;

    К этим тегам относятся элементы, которые располагаются в контейнере <head>. Все эти теги напрямую не отображаются в окне браузера, за исключением тега <title>, который определяет название веб-страницы.
    Это теги <title> и <meta>



    - блочные элементы;

    Блочные элементы характеризуются тем, что занимают всю доступную ширину, высота элемента определяется его содержимым, и он всегда начинается с новой строки.

    <blockquote>
    ыровненный блок с отступами слева и справа (примерно по 40 пикселов), а также с пустым пространством сверху и снизу.

    <div>
    Тег <div> относится к универсальным блочным контейнерам и применяется в тех случаях, где нужны блочные элементы без дополнительных свойств. Также с помощью тега <div> можно выравнивать текст внутри этого контейнера с помощью атрибута align.

    <h1>,...,<h6>
    Эта группа тегов определяет текстовые заголовки разного уровня, которые показывают относительную важность секции, расположенной после заголовка.

    <hr>
    Рисует горизонтальную линию, которая по своему виду зависит от используемых атрибутов. Линия всегда начинается с новой строки, а после нее все элементы отображаются на следующей строке.

    <p>
    Определяет параграф (абзац) текста.

    <pre>
    Задает блок предварительно форматированного текста. Такой текст отображается обычно моноширинным шрифтом и со всеми пробелами между словами. В HTML любое количество пробелов идущих в коде подряд на веб-странице показывается как один. Тег <pre> позволяет обойти эту особенность и отображать текст как требуется разработчику.



    - строчные элементы;

    Строчными называются такие элементы веб-страницы, которые являются непосредственной частью другого элемента, например, текстового абзаца. В основном они используются для изменения вида текста или его логического выделения.

    <a>
    Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь.

    <b>
    Определяет жирное начертание шрифта.

    <big>
    Тег <big> увеличивает размер шрифта на единицу по сравнению с обычным текстом. В HTML размер шрифта измеряется в условных единицах от 1 до 7, средний размер текста, используемый по умолчанию, принят 3. Таким образом, добавление тега <big> увеличивает текст на одну условную единицу.

    <br>
    Тег <br> устанавливает перевод строки в том месте, где этот тег находится. В отличие от тега параграфа <p>, использование тега <br> не добавляет пустой отступ перед строкой.

    <em>
    Тег <em> предназначен для акцентирования текста. Браузеры отображают такой текст курсивным начертанием.

    <i>
    Устанавливает курсивное начертание шрифта.

    <img>
    Тег <img> предназначен для отображения на веб-странице изображений в графическом формате GIF, JPEG или PNG. Если необходимо, то рисунок можно сделать ссылкой на другой файл, поместив тег <img> в контейнер <a>. При этом вокруг изображения отображается рамка, которую можно убрать, добавив атрибут border="0" в тег <img>.

    <small>
    Тег <small> уменьшает размер шрифта на единицу по сравнению с обычным текстом. По своему действию похож на тег <big>, но действует с точностью до наоборот.

    <span>
    Универсальный тег, предназначенный для определения строчного элемента внутри документа.

    <strong>
    Тег <strong> предназначен для акцентирования текста. Браузеры отображают такой текст жирным начертанием.

    <sub>
    Отображает шрифт в виде нижнего индекса. Текст при этом располагается ниже базовой линии остальных символов строки и уменьшенного размера — H2O.

    <sup>
    Отображает шрифт в виде верхнего индекса. По своему действию похож на <sub>, но текст отображается выше базовой линии текста — м2.

    Разница между блочными и строчными элементами следующая.

    Строчные элементы могут содержать только данные или другие строчные элементы, а в блочные допустимо вкладывать другие блочные элементы, строчные элементы, а также данные. Иными словами, строчные элементы никак не могут хранить блочные элементы.
    Блочные элементы всегда начинаются с новой строки, а строчные таким способом не акцентируются.
    Блочные элементы занимают всю доступную ширину, например, окна браузера, а ширина строчных элементов равна их содержимому плюс значения отступов, полей и границ.



    - универсальные элементы;
    Особенность этих тегов состоит в том, что они в зависимости от контекста могут использоваться как блочные или встроенные элементы.

    <del>
    Тег <del> используется для выделения текста, который был удален в новой версии документа. Подобное форматирование позволяет отследить, какие изменения в тексте документа были сделаны. Браузеры обычно помечают текст в контейнере <del> как перечеркнутый.

    <ins>
    Тег <ins> предназначен для акцентирования вновь добавленного текста и обычно применяется наряду с тегом <del>. Браузеры помечают содержимое контейнера <ins> подчеркиванием текста.



    - списки;

    Списком называется взаимосвязанный набор отдельных фраз или предложений, которые начинаются с маркера или цифры. Списки предоставляют возможность упорядочить и систематизировать разные данные и представить их в наглядном и удобном для пользователя виде.

    <ol>
    Тег <ol> устанавливает нумерованный список, т.е. каждый элемент списка начинается с числа или буквы и увеличивается по нарастающей.

    <ul>
    Устанавливает маркированный список, каждый элемент которого начинается с небольшого символа — маркера.

    <li>
    Тег <li> определяет отдельный элемент списка. Внешний тег <ul> или <ol> устанавливает тип списка — маркированный или нумерованный.

    <dd>, <dt>, <dl>
    Тройка элементов предназначена для создания списка определений. Каждый такой список начинается с контейнера <dl>, куда входит тег <dt> создающий термин и тег <dd> задающий определение этого термина. Закрывающий тег </dd> не обязателен, поскольку следующий тег сообщает о завершении предыдущего элемента. Тем не менее, хорошим стилем является закрывать все теги.



    - таблицы;

    Таблица состоит из строк и столбцов ячеек, которые могут содержать текст и рисунки. Обычно таблицы используются для упорядочения и представления табличных данных.

    <table>
    Служит контейнером для элементов, определяющих содержимое таблицы. Любая таблица состоит из строк и ячеек, которые задаются с помощью тегов <tr> и <td>.

    <td>
    Предназначен для создания одной ячейки таблицы. Тег <td> должен размещаться внутри контейнера <tr>, который в свою очередь располагается внутри тега <table>.

    <th>
    Тег <th> предназначен для создания одной ячейки таблицы, которая обозначается как заголовочная. Текст в такой ячейке отображается браузером обычно жирным шрифтом и выравнивается по центру.

    <tr>
    Тег <tr> служит контейнером для создания строки таблицы.



    - фреймы
    
    Фреймы разделяют окно браузера на отдельные области, расположенные вплотную друг к другу. В каждую из таких областей загружается самостоятельная веб-страница определяемая с помощью тега <frame>. С помощью фреймов веб-страница делится на два или более документа, которые обычно содержат навигацию по сайту и его контент. Механизм фреймов позволяет открывать документ в одном фрейме, по ссылке, нажатой в совершенно другом фрейме. Допустимо также использовать вложенную структуру элементов, это позволяет дробить фреймы на мелкие области.

    <frame>
    Тег <frame> определяет свойства отдельного фрейма, на которые делится окно браузера.

    <frameset>
    Тег <frameset> заменяет собой элемент <body> на веб-странице и формирует структуру фреймов.

    <iframe>
    Тег <iframe> создает плавающий фрейм, который находится внутри обычного документа, он позволяет загружать в область заданных размеров любые другие независимые документы.`
    },
    {
        q: `Что такое метатеги и для чего они нужны?`,
        a: `    Мета-теги — часть программного HTML-кода, заключенная между тегом <head>...</head> (заголовок страницы). Эти атрибуты не являются обязательными: они не видны пользователю, но сообщают определенную информацию поисковой системе (описание, заголовок, ключевые слова и т.д.).
               
    Мета теги помогают поисковым роботам понять, о чём ваш сайт. По какому запросу показывать его в выдаче и что конкретно транслировать посетителю в поиске. Конечно, роботы будут скрупулёзно обрабатывать каждую страницу и каждую строку текста на сайте. Но мета теги будут чем-то вроде визитной карточки, на которую робот посмотрит в первую очередь.
    
    Зачем нужен title? Он показывает название страницы. По сути,  на прямой запрос пользователя в поисковике первой же строчкой вылезет именно эта страница
    
    Description является кратким описанием страницы. Он будет показан непосредственно под названием сайта в выдаче, в так называемых сниппетах. Как правило, тег description это блок грамматически связанной, читабельной для пользователя информации длинной до 250 символов. Его цель – дать краткое описание страницы. Зачастую именно это описание и приводит целевых клиентов\пользователей на страницу сайта. Title о многом не скажет, но он нужен роботам. А вот description очень хорошо помогает привлекать на ресурс людей.

    Keywords. Мета тег, который состоит из ключевых слов, встречающихся на странице. Нужен чтобы показать роботам самые важные ключевые слова, т.е. по сути, мы предоставляем данные о семантическом ядре. Это облегчает роботам понимание, куда определить ваш сайт. На какие перекрёстные запросы он должен быть показан в выдаче. И в какой тематической группе транслироваться.`
    },
    {
        q: `Расскажите про списки в HTML`,
        a: `    Списки предоставляют возможность упорядочить и систематизировать разные данные и представить их в наглядном и удобном для пользователя виде.

    Любой список представляет собой контейнер <ul>, который устанавливает маркированный список, или <ol>, определяющий список нумерованный. Каждый элемент списка должен начинаться с тега <li>.
    
    - маркированный список
    
    Маркированный список определяется тем, что перед каждым элементом списка добавляется небольшой маркер, обычно в виде закрашенного кружка. Сам список формируется с помощью контейнера <ul>, а каждый пункт списка начинается с тега <li>, как показано ниже.

    <ul>
    <li>Первый пункт</li>
    <li>Второй пункт</li>
    <li>Третий пункт</li>
    </ul>
    В списке непременно должен присутствовать закрывающий тег </ul>, иначе возникнет ошибка.

    Маркеры могут принимать один из трех видов: круг (по умолчанию), окружность и квадрат. Для выбора стиля маркера используется атрибут type тега <ul>
    
    
    - нумерованный список
    
    Нумерованные списки представляют собой набор элементов с их порядковыми номерами. Вид и тип нумерации зависит от атрибутов тега <ol>, который и применяется для создания списка. Каждый пункт нумерованного списка обозначается тегом <li>, как показано ниже.

    <ol>
    <li>Первый пункт</li>
    <li>Второй пункт</li>
    <li>Третий пункт</li>
    </ol>
    Если не указывать никаких дополнительных атрибутов и просто написать тег <ol>, то по умолчанию применяется список с арабскими числами (1, 2, 3,...)
    
    В качестве нумерующих элементов могут выступать следующие значения:

    арабские числа (1, 2, 3, ...);
    прописные латинские буквы (A, B, C, ...);
    строчные латинские буквы (a, b, c, ...);
    прописные римские числа (I, II, III, ...);
    строчные римские числа (i, ii, iii, ...).
    Для указания типа нумерованного списка применяется атрибут type тега <ol>.
    
    Чтобы начать список с определенного значения, используется атрибут start тега <ol>. При этом не имеет значения, какой тип списка установлен с помощью type, атрибут start одинаково работает и с римскими и с арабскими числами.
    
    
    - список определений
    
    Список определений состоит из двух элементов — термина и его определения. Сам список задается с помощью контейнера <dl>, термин — тегом <dt>, а его определение — с помощью тега <dd>
    
    Список определений хорошо подходит для расшифровки терминов, создания глоссария, словаря, справочника и т.д.`
    },
    {
        q: `Возможны ли комментарии в HTML?`,
        a: `    Комментарий в HTML-коде задаётся так:

    <!-- любой текст -->
    Текст внутри комментария не отображается браузером на странице`
    },
    {
        q: `Что такое Charset?`,
        a: `    Указывает кодировку документа. Атрибут введен в HTML5 и предназначен для сокращения формы тега <meta>, которая задавала кодировку в предыдущих версиях HTML и XHTML
        
    <meta charset="кодировка">`
    },
    {
        q: `Что такое атрибуты в HTML?`,
        a: `    У элементов HTML есть атрибуты; это дополнительные значения, которые настраивают элементы или регулируют их поведение различным способом, чтобы соответствовать критериям пользователей
        
    Все атрибуты состоят из двух частей — это имя и значение:

    Имя — это свойство, которое Вы хотите установить. Например, элемент абзаца <p>, в примере ниже, содержит атрибут align, который Вы можете использовать для указания выравнивания абзаца на странице.
    Значение — это значение, которое Вы хотите установить для свойства. Значение атрибута всегда помещается в кавычки. В приведенном ниже примере показаны три возможных значения атрибута align: left, center и right.
    Имена и значения атрибутов в HTML не зависят от регистра. Однако консорциум World Wide Web (W3C) рекомендует в своей рекомендации HTML 4 использовать атрибуты и значения атрибутов в нижнем регистре.
    
    Основные атрибуты HTML

    Общие атрибуты
    
    align - Горизонтальное выравнивание тегов.

    valign - Вертикальное выравнивание тегов внутри html-элемента.
    
    bgcolor - Помещает фоновый цвет за элемент

    background - Помещает фоновое изображение за элемент
    
    id - Именование элемента для использования с каскадными таблицами стилей
    
    class - Классифицирует элемент для использования с каскадными таблицами стилей
    
    width - Задает ширину таблиц, изображений или ячеек таблицы
    
    height - Задает высоту таблиц, изображений или ячеек таблицы
    
    title - «Всплывающий» заголовок элементов

    Существует четыре основных атрибута в HTML, которые могут использоваться для большинства html-элементов (хотя и не для всех):

    id
    title
    class
    style
    Атрибут id
    Атрибут id html-тега может быть использован для однозначной идентификации любого элемента внутри html-страницы. Существуют две основные причины, по которым Вы можете использовать атрибут id для элемента:

    Если элемент содержит атрибут id как уникальный идентификатор, то можно идентифицировать только этот элемент и его содержимое.
    Если на веб-странице (или в таблице стилей) есть два элемента с одним и тем же именем, Вы можете использовать атрибут id для различения элементов, имеющих одно и то же имя.
    Таблицу стилей мы обсудим в отдельном самоучителе. Пока же давайте использовать атрибут id для различения двух элементов абзаца, как показано ниже.

    <p id="html">Этот абзац объясняет, что такое HTML.</p>
    <p id="css">Этот абзац объясняет, что такое каскадная таблица стилей (CSS).</p>



    Атрибут title
    Атрибут title — дает название элемента для элемента. Синтаксис для атрибута title аналогичен атрибуту id.

    Поведение этого атрибута будет зависеть от элемента, который его несет, хотя он часто отображается как подсказка, когда курсор наводится на элемент или когда элемент загружается.

    Пример

    <!DOCTYPE html>
    <html>
    <head>
        <title>Пример атрибута title</title>
    </head>
    <body>
        <h2 title="Привет самоучитель по HTML!">Пример заголовка</h2>
    </body>
    </html>


    
    Атрибут class
    Атрибут class — используется для связывания элемента со списком стилей и задает класс элементу. Вы узнаете больше об использовании атрибута class, когда изучите CSS (каскадные таблицы стилей). Так что пока можете это пропустить.

    Значением атрибута может быть также список имен классов, разделенных пробелами. Например:

    class="названиеКласса1 названиеКласса2 названиеКласса3"
    
    
    Атрибут style
    Атрибут style — позволяет указывать правила каскадной таблицы стилей (CSS) внутри элемента.

    <!DOCTYPE html>
    <html>
    <head>
        <title>Пример атрибута style</title>
    </head>
    <body>
        <p style="align: center; color: #008cff;">Немного текста... </p>
    </body>
    </html>
    
    
    Атрибуты интернационализации
    Существует три атрибута интернационализации в HTML, которые доступны для большинства (хотя и не для всех) элементов XHTML.

    dir
    lang
    xml:lang


    Атрибут dir
    Атрибут dir — позволяет указать браузеру направление потока текста (слева- направло или справа- налево)
    
    Атрибут lang
    Атрибут lang — позволяет указать основной язык, используемый в документе, но этот атрибут хранится в HTML только для обратной совместимости с более ранними версиями HTML. 
    
    Атрибут xml:lang
    Атрибут xml:lang — это XHTML замена для атрибута lang`
    },
    {
        q: `Что такое Important в CSS?`,
        a: `    Декларация !important - это ключевое слово, которое может быть добавлено в конце любой пары ключ/значение. Например:

    p {margin-left: 5px !important}
    p {margin: 10px 5px 0 10px !important}
    Каково её влияние?
    CSS присваивает вес каждому правилу, в зависимости от его выборки и позиции в исходном элементе. Это определяет стиль HTML-элемента.
    
    Если появляются два конфликтующих правила, то применяется следующий подход для его разрешения:
    
    Источник правила - если одно правило находится в таблице стилей сайта, а второе непосредственно на клиентском компьютере, то применено будет правило клиента.
    Специфика - если два или более правил имеют отношение к одному и тому же свойству, одного и того же элемента, а также один уровень важности и один источник, то будет применено правило более конкретного селектора.
    Порядок - если у двух правил один вес, то будет применено последнее.
    Иногда необходимо поменять приоритет правил. Разорвать цепочку каскада можно с помощью декларации !important. В случае её использования, отмеченное правило будет иметь самый высокий "вес" и именно оно будет использоваться.
    
    В следующем примере, второй селектор является более конкретным и объявлено в конце, но использоваться будет именно первое правило, поскольку в нём используется декларация !important, которое заменяет все остальные правила.
    
    p {margin-left: 5px !important}
    #id p {margin-left: 10px}
        
        Замена inline-стилей
    !important может использоваться для переопределения inline-стилей, которые обычно генерируются WYSIWYG-редакторами в различных CMS.

    Форматирование текста в таких редакторах осуществляется с помощью вставленных напрямую в html-разметку стилей. Эти стили можно переопределить в таблице стилей, используя декларацию !important.

    Например, пользователь хочет вывести текст красным цветом

    <div id="content"><p style="color:red">Some text</p></div>
    Однако автор сайта может переопределить этот стиль, чтобы текст всех параграфов выводился, например, чёрным цветом:

    #content p {color:black !important}
    Стилевые файлы для печати
    Декларация !important также часто используется в таблицах стилей, предназначенных для печати. В этом случае автор сайта уверен, что страница печатается так, как он и предполагал.

    Обратная сторона
    Есть только один способ переопределить стиль отмеченный !important - это использовать более конкретный селектор и также отметить используемый стиль декларацией. Всё это может сделать файл стилей сильно запутанным и сложным для понимания.

    В CSS1 декларация !important автора сайта имела больший приоритет над пользовательским файлом стилей. Это правило изменилось в CSS2, то есть пользователь всегда может переопределить внешний вид сайта.

    Заключение
    Использование декларации !important может сделать файл стилей сложным для понимания и отладки, однако если быть аккуратным, то она поможет вам сохранить время и нервы.`
    },
    {
        q: `Вес CSS селекторов`,
        a: `    `
    },
    {
        q: `Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?`,
        a: `    Объекты копируются по ссылке. Если мы просто запишем переменной, что ее значение равняется существующему объекту, то такое копирование называется поверхностным
        
    А чтобы создать точно такой же независимы объект используются слудующие методы:
    
    1. let newArr = Object.assign({}, obj);
    
    2. let newArr = {...obj};
    
    3. let newArr = JSON.parse(JSON.stringify(arr))`
    },
    {
        q: `Что такое цепочка вызовов функций (chaining) ? Как реализовать такой подход?`,
        a: `    Это подход, при котором методы объекта вызываются один за другим без дополнительного обращения к исходному объекту
        
    Например это методы строк или массивов. Или в промисах then и catch`,
        i: 'chaining'
    },
    {
        q: `Что такое необъявленная переменная?`,
        a: `    Необъявленная переменная - это переменная, которая объявляется без использования var, let и const
        
    str = 'stroke
    
    Если не использовать use strict, то такая переменная становится глобальной и ее можно использовать везде
    
    Но при строгом режиме при обращении к такой переменной мы получим ошибку`
    },
    {
        q: `Как передаются параметры в функцию по ссылке или по значениею?`,
        a: `    Параметры, которые передаются в функцию всегда передаются по значению.

    Но если у нас есть объект, мы создаем функцию, внтури ее создаем переменную и в качестве значения переменной присваиваем наш объект, то если внутри функции мы поменяем свойства этого объекта, то они поменяются везде

    let obj = {
        name: 'Aleh',
        surname: 'Shchurko'
    }
    
    let func = () => {
        let newObj = obj;
    
        newObj.name = 'Ivan'
    }
    func();
    
    console.log(obj.name); // Ivan`
    },
    {
        q: `Разница между обычными функциями и стрелочными?`,
        a: `    1. В обычных функциях this - это ссылка на объект, который вызывает эту функцию. А в стрелочных функциях this ссылается на объект window
        
    2. Стрелочную функцию нельзя использовать как функцию конструктор
    
    3. При использовании обычных функций есть доступ к псевдомассиву arguments, У стрелочных функций такого псевдомассива нет
    
    4. В стрелочных функциях необязательно указывать return при сокращенной форме записи
    
    5. Стрелочную функцию можно как и обычную использовать внутри класса, т.е. она будет методом. И если этот метод попытаться использовать гдето как callback, например отдельно в коде вызвать ее через setTimeout, то this в обычной функции пропадет, а в стрелочной нет и он здесь будет ссылаться на объект класса, в котором этот метод был объявлен`
    },
    {
        q: `Вес селекторов в CSS?`,
        a: `    Какой вес будет у элемента?
        
    Вес селекторов (по убыванию):

    style=""1,0,0,0
    
    #id0,1,0,0
    
    .class0,0,1,0
    
    [attr=value]0,0,1,0
    
    LI0,0,0,1
    
    *0,0,0,0
    
    У стилей, заданных в атрибуте style, на первой позиции будет единица — 1,0,0,0. Это самая высокая специфичность, которая перевешивает свойства, заданные другими способами.
    
    Переопределить стили, заданные в style, можно дописав !important к значению свойства в таблице стилей.
    
    Обратный вариант — универсальный селектор *, он не имеет веса: 0,0,0,0.
    
    Примеры:
    
    LI0,0,0,1 — селектор по тегу
    
    UL LI0,0,0,2 — селектор c двумя тегами весит больше, чем с одним.
    
    .orange0,0,1,0 — селектор с классом весит больше, чем селектор с тегом.
    
    .orange A SPAN0,0,1,2 — селектор перевесит предыдущий, потому что помимо класса содержит два тега.
    
    #page .orange0,1,1,0 — селектор с ID перевесит всё, кроме inline-стилей.
    
    
    Основные правила весов
 
    - Вес, определенный в HTML всегда выше, чем вес, определенный в CSS.

     - Если есть два разных значения свойства элемента и вес они имеют одинаковый, то применится свойство, которое записано в коде ниже
     
    - .
    `
    },
    {
        q: `Какой вес будет у элемента "body #content .data img:hover" ?`,
        a: `    Конечное значение веса - 0122; #content - селектор идентификатора плюс 100, .data - селектор класса плюс 10: селектор псевдокласса hover плюс 10, body и img - элементы плюс 1`
    },
    {
        q: `Как уменьшить вес селектора # ?`,
        a: `    Предположим у вас есть виджет на странице и вы хотите его стилизовать:

       
        <div id="widget">
            ...
        </div>
        И, например, мы не можем изменять HTML код виджета, чтобы избавиться от ID. Поэтому мы делаем так:
                
        #widget {
            ...
        }
        В результате мы имеем определение для ID в CSS файле, что совсем нехорошо. Вместо этого мы можем сделать следующее:
                
        [id="widget"] {
            ...
        }
        
        Это селектор атрибута. В данном случае это уже определение не для ID, а для элемента. Если говорить точно, то селектор говорит: «Эй, найди мне элемент, у которого есть атрибут id со значением widget».
        
        Прелесть такого подхода в том, что мы снизили вес ID до веса класса`
    },
    {
        q: `Что такое форма и как ее сверстать?`,
        a: `    Форма — это компонент веб-страницы с элементами управления, такими как текстовые поля, кнопки, флажки, диапазон или поле выбора цвета. Пользователь может взаимодействовать с такой формой, предоставляя данные, которые затем могут быть отправлены на сервер для дальнейшей обработки (например, возвращая результаты поиска или вычислений).

    Написание формы состоит из нескольких шагов, которые могут выполняться в любом порядке: написание пользовательского интерфейса, реализация обработки на стороне сервера и настройка пользовательского интерфейса для связи с сервером.
    
    Чтобы добавить форму на страницу мы будем использовать элемент <form>. Данный элемент определяет, где на странице появятся элементы управления. Кроме того, элемент <form> обёртывает все элементы включенные в форму, подобно элементу <div>.

    <form action="/login" method="post">
    ...
    </form>

    К элементу <form> может применяться горстка различных атрибутов, наиболее распространёнными из которых являются action и method. Атрибут action содержит URL, на который информация в форме будет отправлена для обработки сервером. Атрибут method является методом HTTP, который должны использовать браузеры для отправки данных формы. Оба эти атрибута <form> имеют отношение к отправке и обработке данных.

    Текстовые поля и текстовые области
    Когда дело доходит до сбора текстовой информации от пользователей, есть несколько разных элементов, доступных для получения данных в формах. В частности, для сбора данных на основе текста или строки применяются текстовые поля и текстовые области. Эти данные могут включать в себя отрывки текста, пароли, номера телефонов и другую информацию.

    Текстовые поля
    Одним из основных элементов, используемых для получения текста от пользователей, является элемент <input>. Данный элемент включает атрибут type для определения, какой тип информации будет получен в элементе управления. Наиболее популярное значение атрибута type — это text, который обозначает ввод одной строки текста.

    Наряду с установкой атрибута type, хорошей практикой будет также дать элементу <input> атрибут name. Значение атрибута name применяется в качестве имени элемента управления и отправляется вместе с входными данными на сервер.

    <input type="text" name="username">
    
    
    <textarea>
    Ещё одним элементом, используемым для сбора текстовых данных, является элемент <textarea>. Он отличается от элемента <input> тем, что может принимать большие отрывки текста в несколько строк. Элемент <textarea> также содержит начальный и конечный теги, которые могут обернуть простой текст. Поскольку <textarea> принимает только один тип значения, атрибут type здесь не применим, но атрибут name по прежнему используется.

    <textarea name="comment">Добавьте сюда свой комментарий</textarea>
    
    
    Поля множественного выбора и меню
    Помимо текстовых полей, HTML также позволяет пользователям выбирать данные, используя множественный выбор и раскрывающиеся списки. Есть несколько разных вариантов и полей для этих элементов формы, каждый из которых имеет свои отличительные преимущества.

    Переключатели
    Переключатели — это простой способ, позволяющий пользователям сделать быстрый выбор из небольшого списка вариантов. Переключатели дают пользователю выбрать только один вариант в отличие от нескольких.

    Чтобы создать переключатель, используется элемент <input> со значением radio у атрибута type. Каждый переключатель должен иметь одинаковое значение атрибута name, чтобы все они в группе были связаны друг с другом.

    С текстовыми полями их значение определяется тем, что пользователь в них набирает; с переключателями пользователь делает множественный выбор. Таким образом, мы должны определить входное значение. Используя атрибут value мы можем установить конкретное значение для каждого элемента <input>.

    Кроме того, для предварительного выбора переключателя мы можем использовать логический атрибут checked.

    <input type="radio" name="day" value="Friday" checked> Пятница
    <input type="radio" name="day" value="Saturday"> Суббота
    <input type="radio" name="day" value="Sunday"> Воскресенье
    
    
    
    Флажки
    Флажки очень похожи на переключатели. Они используют те же атрибуты и шаблоны, за исключением значения атрибута type. Разница между ними состоит в том, что флажки позволяют пользователям выбрать несколько значений и связать их все с одним именем, в то время как переключатели ограничивают пользователей одним значением.

    <input type="checkbox" name="day" value="Friday" checked> Пятница
    <input type="checkbox" name="day" value="Saturday"> Суббота
    <input type="checkbox" name="day" value="Sunday"> Воскресенье
    
    
    Выпадающие списки
    Выпадающие списки являются идеальным способом, чтобы практическим образом предоставить пользователям длинный список вариантов. Длинный столбец переключателей рядом со списком разных вариантов не только визуально непривлекателен, но кроме того сложен и труден для понимания, особенно на мобильном устройстве. Выпадающие списки, с другой стороны, обеспечивают идеальный формат для длинного списка вариантов.

    Для создания выпадающего списка мы будем применять элементы <select> и <option>. Элемент <select> оборачивает все пункты меню, а каждый пункт меню размечен с помощью элемента <option>.

    Атрибут name располагается в элементе <select>, а атрибут value располагается в элементах <option>, вложенных в элемент <select>. Таким образом, атрибут value в каждом элементе <option> связан с атрибутом name элемента <select>.

    Каждый элемент <option> оборачивает текст (который виден пользователям) отдельного пункта в списке.

    Подобно логическому атрибуту checked у переключателей и флажков, для выпадающего меню можно использовать логический атрибут selected, чтобы предварительно выделить пункт для пользователей.

    <select name="day">
    <option value="Friday" selected>Пятница</option>
    <option value="Saturday">Суббота</option>
    <option value="Sunday">Воскресенье</option>
    </select>
    
    
    Логический атрибут multiple при добавлении к элементу <select> для стандартного выпадающего списка позволяет пользователю выбрать более одного варианта из списка одновременно. Кроме того, с помощью логического атрибута selected, добавленного к более чем одному элементу <option>, в меню можно заранее выбрать несколько вариантов.

    Размером элемента <select> можно управлять с помощью CSS и он должен быть скорректирован соответствующим образом для множественного выбора. Возможно, есть смысл информировать пользователей, что для выбора нескольких вариантов они должны удерживать клавишу Shift во время щелчка, чтобы сделать выбор.

    <select name="day" multiple>
    <option value="Friday" selected>Пятница</option>
    <option value="Saturday">Суббота</option>
    <option value="Sunday">Воскресенье</option>
    </select>
    
    
    Кнопки в форме
    После того, как пользователь вводит запрашиваемую информацию, кнопки позволяют пользователю пустить эту информацию в дело. Чаще всего для обработки данных используются поле или кнопка для отправки.

    Поле для отправки
    Когда пользователь щёлкает по кнопке, данные формы обрабатываются после её заполнения. Кнопка для отправки создаётся с помощью элемента <input> со значением submit у атрибута type. Атрибут value применяется для указания текста, который отображается внутри кнопки.

    <input type="submit" name="submit" value="Отправить">
    
    
    Кнопка для отправки
    Кнопка для отправки в виде элемента <input> является самодостаточной и не может оборачивать любой другой контент. Если хочется иметь больше контроля над структурой и дизайном поля, наряду с возможностью обернуть другие элементы — тогда может быть использован элемент <button>.

    Элемент <button> выполняет то же самое, что и элемент <input> со значением submit у атрибута type. Однако, он включает в себя открывающий и закрывающий теги, которые могут обернуть другие элементы. По умолчанию, элемент <button> действует, как если у атрибута type задано значение submit, поэтому атрибут type и его значение можно по желанию опустить.

    Вместо использования атрибута value для управления текстом в кнопке для отправки, будет показан текст, который пишется между открывающим и закрывающим тегами элемента <button>.

    <button name="submit">
    <strong>Отправьте нам</strong> сообщение
    </button>
    
    
    Другие поля
    Помимо применения, которое мы только что обсудили, элемент <input> имеет несколько других вариантов использования. Они включают в себя получение скрытых данных и прикрепление файлов в процессе обработки формы.

    Скрытое поле
    Скрытые поля предоставляют способ передачи данных на сервер без отображения их пользователям. Скрытые поля обычно используются для отслеживания кодов, ключей или другой информации, которая не имеет отношения к пользователю, но может быть полезна при обработке формы. Эта информация не отображается на странице, однако может быть найдена путём просмотра исходного кода страницы. По этой причине она не должна применяться для уязвимой или защищённой информации.

    Чтобы создать скрытое поле используйте значение hidden атрибута type. Дополнительно включает в себя соответствующие значения атрибутов name и value.

    <input type="hidden" name="tracking-code" value="abc-123">
    Поле для файла
    Чтобы позволить пользователям добавить файл в форму, вроде прикрепления файла к письму, используйте значение file атрибута type.

    <input type="file" name="file">
    
    
    <label>
    Элемент <label> содержит подписи или заголовки для управления формой, однозначно связывая их вместе, создавая тем самым доступную форму для всех пользователей и вспомогательных технологий. <label> должны включать в себя текст, описывающий поля к которым они относятся.

    <label> могут включать в себя атрибут for, его значение должно быть таким же, как значение атрибута id у элемента, с которым связан <label>. Соответствие значений атрибутов for и id связывает два элемента вместе, что позволяет пользователям нажать на <label> и передать фокус нужному полю формы.

    <label for="username">Имя пользователя</label>
    <input type="text" name="username" id="username">
    
    
    При желании, <label> может обернуть поля формы, такие как переключатели или флажки. Это позволяет опустить атрибуты for и id.

    <label>
    <input type="radio" name="day" value="Friday" checked> Пятница
    </label>
    <label>
    <input type="radio" name="day" value="Saturday"> Суббота
    </label>
    <label>
    <input type="radio" name="day" value="Sunday"> Воскресенье
    </label>
    
    
    <fieldset>
    <fieldset> группирует поля формы в организованные разделы. Подобно <section> или иным структурным элементам, но <fieldset> является блочным элементом, который оборачивает связанные элементы, в частности, в <form>, для их лучшей организации. <fieldset> по умолчанию также включают в себя границы контура, которые могут быть изменены с помощью CSS.

    <fieldset>
    <label>
        Имя пользователя
        <input type="text" name="username">
    </label>
    <label>
        Пароль
        <input type="text" name="password">
    </label>
    </fieldset>
    
    
    <legend>
    Элемент <legend> предоставляет подпись или заголовок для элемента <fieldset>. Элемент <legend> оборачивает текст, описывающий элементы управления формы, которые находятся внутри <fieldset>. Разметка должна включать в себя элемент <legend> сразу после открывающего тега <fieldset>. На странице подпись появится в левом верхнем углу рамки <fieldset>.

    <fieldset>
    <legend>Вход в систему</legend>
    <label>
        Имя пользователя
        <input type="text" name="username">
    </label>
    <label>
        Пароль
        <input type="text" name="password">
    </label>
    </fieldset>
    
    
    
    disabled - делаетполе ввода недоступным

    readonly - в поле введены данные, но изменить их нельзя

    placeholder - добавляет текст заменитель. Например "введите ваше имя"

    maxlength - максимальное количество символов
    
    required - говорит о то, что поле обязательно должно быть заполнено
    
    select - поле с выпадающим списком`
    },
    {
        q: `Порядок отображения flex-элементов и ориентация?`,
        a: `    Направление главной оси: flex-direction
    Свойство относится к flex-контейнеру. Управляет направлением главной оси, вдоль которой укладываются flex-элементы, в соответствии с текущим режимом записи.
    
    Свойство не наследуется
    
    Параметры flex-direction:
    
    - row - Значение по умолчанию, слева направо. Flex-элементы выкладываются в строку. Начало (main-start) и конец (main-end)
    
    - row-reverse - Направление справа налево
    
    - column - Направление сверху вниз. Flex-элементы выкладываются в колонку
    
    - column-reverse - Колонка с элементами в обратном порядке, снизу вверх
    
    - initial - Устанавливает значение свойства в значение по умолчанию
    
    - inherit - Наследует значение свойства от родительского элемента
    `
    },
    {
        q: `Расскажите про выравнивание по осям во flexbox?`,
        a: `    Выравнивание по главной оси: justify-content
        Свойство выравнивает flex-элементы по главной оси flex-контейнера
        
    flex-start - элементы располагаются с начала flex-контейнера
    
    flex-end - flex-элементы размещаются в конце flex-контейнера
    
    center - flex-элементы выравниваются по центру
    
    space-between - первый элемент с начала, последний элемент - с конца, остальные равномерно распределяются
    
    space-around - все элементы располагаются равномерно, а расстояние от первого элементв до начала и также последнего элемента до конца - равно половине расстояния между элементами
    
    
    Выравнивание по поперечной оси: align-items
    
    Flex-элементы можно выравнивать по поперечной оси текущей строки flex-контейнера. align-items устанавливает выравнивание для всех элементов flex-контейнера, включая анонимные flex-элементы. align-self позволяет переопределить это выравнивание для отдельных flex-элементов.
    
    flex-start - Верхний край flex-элемента выравнивается по верхнему краю контейнера
    
    flex-end - Нижний край flex-элемента выравнивается по нижнему краю контейнера
    
    center - выравнивается по центру по высоте
    
    baseline - Базовые линии всех flex-элементов, участвующих в выравнивании, совпадают
    
    stretch - выравнивает все элементы по высоте
    
    initial - Устанавливает значение свойства в значение по умолчанию.


    inherit - Наследует значение свойства от родительского элемента.
    `
    },
    {
        q: `Расскажите про свойство z- index`,
        a: `    Элементы на странице могут как бы накладываться сверху друг на друга. Чтобы понять, какой из элементов все-таки будет виден на экране используется свойство z- index
        
    В качестве значения используются целые числа (положительные, отрицательные и ноль). Чем больше значение, тем выше находится элемент по сравнению с теми элементами, у которых оно меньше. При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML описан ниже

    Значения
    auto

    Контейнер не будет создавать локального контекста наложения. Уровень контейнера в текущем контексте наложения такой же, как и у родительского.

    <integer>

    Целое число определяет уровень контейнера в текущем контексте наложения. Контейнер также будет создавать локальный контекст наложения, в котором его собственный уровень будет равен 0. Это значит, что значения z-index нижестоящих элементов не будут сравниваться с z-индексами элементов вне этого контейнера.
    `
    },
    {
        q: `ЧТо делает свойство transform в CSS ?`,
        a: `    CSS-свойство transform позволяет вам поворачивать, масштабировать, наклонять или сдвигать элемент.
        
    Трансформации преобразовывают элемент, не затрагивая остальные элементы веб-страницы, т.е. другие элементы не сдвигаются относительно него

    В HTML трансформируемый элемент это: элемент с display: block; и display: inline-block;, а также элементы, значение свойства display которых вычисляется как table-row, table-row-group, table-header-group, table-footer-group, table-cell или table-caption
    
    none - Значение по умолчанию, означает отсутствие трансформации
    
    matrix(a, c, b, d, x, y) - 
    Значение a изменяет масштаб по горизонтали. Значение от 0 до 1 уменьшает элемент, больше 1 — увеличивает.
    Значение c деформирует (сдвигает) стороны элемента по оси Y, положительное значение — вверх, отрицательное — вниз.
    Значение b деформирует (сдвигает) стороны элемента по оси X, положительное значение — влево, отрицательное — вправо.
    Значение d изменяет масштаб по вертикали. Значение меньше 1 уменьшает элемент, больше 1 — увеличивает.
    Значение x смещает элемент по оси X, положительное — вправо, отрицательное — влево.
    Значение y смещает элемент по оси Y, положительное значение — вниз, отрицательное — вверх.
    
    translate(x,y) - Сдвигает элемент на новое место, перемещая относительно обычного положения вправо и вниз, используя координаты X и Y, не затрагивая при этом соседние элементы
    
    scale(x,y) - Масштабирует элементы, делая их больше или меньше. Значения от 0 до 1 уменьшают элемент. Первое значение масштабирует элемент по ширине, второе — по высоте.
    
    rotate(угол) - Поворачивает элементы на заданное количество градусов
    
    skew(x-угол,y-угол) - Используется для деформирования (искажения) сторон элемента относительно координатных осей
    `
    },
    {
        q: `Свойство float в CSS`,
        a: `    CSS-свойство float указывает, что текущий элемент должен быть изъят из обычного flow (потока) и прижат к левой или правой стороне родительского элемента. Текст и inline элементы будут обтекать такой элемент
        
    left
    Выравнивает элемент по левому краю, а все остальные элементы, вроде текста, обтекают его по правой стороне.
    right
    Выравнивает элемент по правому краю, а все остальные элементы обтекают его по левой стороне.
    none
    Обтекание элемента не задается.
    inherit
    Наследует значение родителя.`
    },
    {
        q: `Расскажите про приведение типов в Java Script`,
        a: `    Приведение типов — это процесс преобразования значений из одного типа в другой (например — строки в число, объекта — в логическое значение, и так далее). Любой тип в JavaScript, идёт ли речь о примитивном типе, или об объекте, может быть преобразован в другой тип
        
    Преобразование типов может быть явным и неявным. Яанове - это когда мы сами преобразовываем один тип в другой. Например, преобразовываем строку в число
    let str = '12';
    let newStr = +str // преобразится в число 12
    
    Неявное преобразование - это автоматическое изменение типа
    
    Есть три вида преобразований:

    В строку (String)
    В логическое значение (Boolean)
    В число (Number)
    
    Преобразование к типу String

    Для того чтобы явно преобразовать значение в строку, можно воспользоваться функцией String(). Неявное преобразование вызывает использование обычного оператора сложения, +, с двумя операндами, если один из них является строкой:

    String(123) // явное преобразование
    123 + ''    // неявное преобразование

    Все примитивные типы преобразуются в строки вполне естественным и ожидаемым образом:

    String(123)          // '123'
    String(-12.3)       // '-12.3'
    String(null)       // 'null'
    String(undefined) // 'undefined'
    String(true)     // 'true'
    String(false)   // 'false'
    
    
    Для того, чтобы явно преобразовать значение к логическому типу, используют функцию Boolean(). Неявное преобразование происходит в логическом контексте, или вызывается логическими операторами (|| && !)
    
    Так как при приведении значения к логическому типу возможны лишь два результата — true или false, легче всего освоить этот вид преобразований, запомнив те выражения, которые выдают false:

    Boolean('')         // false
    Boolean(0)         // false     
    Boolean(-0)        // false
    Boolean(NaN)       // false
    Boolean(null)      // false
    Boolean(undefined) // false
    Boolean(false)     // false
    
    Любое значение, не входящее в этот список, преобразуется в true, включая объекты, функции, массивы, даты
    Boolean({})             // true
    Boolean([])             // true
    Boolean(Symbol())       // true
    !!Symbol()              // true
    Boolean(function() {})  // true
    
    
    
    Преобразование к типу Number

    Явное преобразование к числовому типу выполняется с помощью функции Number() — то есть по тому же принципу, который используется для типов Boolean и String.

    Неявное приведение значения к числовому типу — тема более сложная, так как оно применяется, пожалуй, чаще чем преобразование в строку или в логическое значение. А именно, преобразование к типу Number выполняют следующие операторы:

    Операторы сравнения (>, <, <=, >=).
    Побитовые операторы (|, &, ^, ~).
    Арифметические операторы (-, +, *, /, %). Обратите внимание на то, что оператор + с двумя операндами не вызывает неявное преобразование к числовому типу, если хотя бы один оператор является строкой.
    Унарный оператор +.
    Оператор нестрогого равенства == (а также !=). Обратите внимание на то, что оператор == не производит неявного преобразования в число, если оба операнда являются строками.
    
    Number('123')   // явное преобразование
    +'123'          // неявное преобразование
    123 != '456'    // неявное преобразование
    4 > '5'         // неявное преобразование
    5/null          // неявное преобразование
    true | 0        // неявное преобразование

    Вот как в числа преобразуются примитивные значения:

    Number(null)                   // 0
    Number(undefined)              // NaN
    Number(true)                   // 1
    Number(false)                  // 0
    Number(" 12 ")                 // 12
    Number("-12.34")               // -12.34
    Number(" 12s ")                // NaN
    Number(123)                    // 123
    
    При преобразовании строк в числа система сначала обрезает пробелы, находящиеся в начале или в конце строки, и возвращает NaN, если полученная строка не является действительным числом. Если строка пуста — возвращается 0.

    Значения null и undefined обрабатываются иначе: null преобразуется в 0, в то время как undefined превращается в NaN
        `
    },
    {
        q: `Какой результат у выражения: true + false ?`,
        a: `    1`
    },
    {
        q: `Какой результат у выражения: 12 / "6" ?`,
        a: `    2
    Знак деления / переводит строку "6" в число 6`
    },
    {
        q: `Какой результат у выражения: 15 + 3 + "number" ?`,
        a: `    '18number'`
    },
    {
        q: `Какой результат у выражения: "foo" + + "bar" ?`,
        a: `    'fooNaN'
        
    Второй плюч попытается привести "bar" к числу. Но т.к. это не целое число, получим NaN. Далее строка "foo" складывается с NaN. В этом случае NaN переведется в строку и на выходе получится строка "fooNaN"`
    },
    {
        q: `Какой результат у выражения: 'true' == true ?`,
        a: `    // false
        
    При двойном равно == значения приводятся к числовому типу. 'true' не являяется целым числом, поэтому при попытке преобразовать его в число, получим NaN. True переведет к единице. В итоге NaN не равен 1, поэтому false`
    },  
    {
        q: `Какой результат у выражения: false == 'false' ?`,
        a: `    // false
        
    При двойном равно == значения приводятся к числовому типу. 'false' не являяется целым числом, поэтому при попытке преобразовать его в число, получим NaN. false переведет к 0. В итоге 0 не равен NaN, поэтому false`
    },
    {
        q: `Какой результат у выражения: null == '' ?`,
        a: `    // false
        
    При двойном равно null равен только undefined и ничему больше, поэтому false`
    },
    {
        q: `Какой результат у выражения: !!"false" == !!"true"`,
        a: `    // true
        
    !! преобразует значение в логический тип. Обе строки преобразуются в true, сравниваем true с true, они переводятся в числа. 1 == 1// true`
    },
    {
        q: `Какой результат у выражения: ['x'] == 'x'`,
        a: `    // true
        
        Оператор == вызывает для массивов преобразование к числовому типу. Метод объекта Array.valueOf() возвращает сам массив, и это значение игнорируется, так как оно не является примитивом. Метод массива toString() преобразует массив ['x'] в строку 'x'.

        ['x'] == 'x'  
        ==> 'x' == 'x'
        ==>  true`
    },
    {
        q: `Какой результат у выражения: [] + null + 1`,
        a: `    // 'null1'
        
        Оператор + вызывает преобразование в число для пустого массива []. Метод объекта Array valueOf() игнорируется, так как он возвращает сам массив, который примитивом не является. Метод массива toString() возвращает пустую строку.

        На втором шаге вычисляется значение выражения '' + null + 1.
        
        [] + null + 1  
        ==>  '' + null + 1  
        ==>  'null' + 1  
        ==> 'null1'`
    },
    {
        q: `Какой результат у выражения: 0 || «0» && {}`,
        a: `    // {}
        
        Логические операторы || и && в процессе работы приводят значение операндов к логическому типу, но возвращают исходные операнды (которые имеют тип, отличный от логического). Значение 0 ложно, а значение '0' истинно, так как является непустой строкой. Пустой объект {} так же преобразуется к истинному значению.

        0 || "0" && {}  
        ==>  (0 || "0") && {}
        ==> (false || true) && true  // внутреннее преобразование
        ==> "0" && {}
        ==> true && true             // внутреннее преобразование
        ==> {}`
    },
    {
        q: `Какой результат у выражения: [1,2,3] == [1,2,3]`,
        a: `    // false
        
        Преобразование типов не требуется, так как оба операнда имеют один и тот же тип. Так как оператор == выполняет проверку на равенство ссылок на объекты (а не на то, содержат ли объекты одинаковые значения) и два массива являются двумя разными объектами, в результате будет выдано false.

        [1,2,3] == [1,2,3]
        ==>  false`
    },
    {
        q: `Какой результат у выражения: {}+[]+{}+[1]`,
        a: `    // '0[object Object]1'
        
        Все операнды не являются примитивными значениями, поэтому оператор + начинается с самого левого и вызывает его преобразование к числу. Метод valueOf для типов Object и Array возвращают сами эти объекты, поэтому это значение игнорируется. Метод toString() используется как запасной вариант. Хитрость тут в том, что первая пара фигурных скобок {} не рассматривается как объектный литерал, она воспринимается как блок кода, который игнорируется. Вычисление начинается со следующего выражения, +[], которое преобразуется в пустую строку через метод toString(), а затем в 0.

        {}+[]+{}+[1]
        ==> +[]+{}+[1]
        ==> 0 + {} + [1]
        ==> 0 + '[object Object]' + [1]
        ==> '0[object Object]' + [1]
        ==> '0[object Object]' + '1'
        ==> '0[object Object]1'`
    },
    {
        q: `Какой результат у выражения: !+[]+[]+![]`,
        a: `    // 'truefalse'
        
        Этот пример лучше объяснить пошагово в соответствии с порядком выполнения операций.

        !+[]+[]+![]  
        ==> (!+[]) + [] + (![])
        ==> !0 + [] + false
        ==> true + [] + false
        ==> true + '' + false
        ==> 'truefalse'`
    },
    {
        q: `Какой результат у выражения: new Date(0) — 0`,
        a: `    // 0
        
        Оператор - вызывает преобразование в число для объекта типа Date. Метод Date.valueOf() возвращает число миллисекунд с начала эпохи Unix.

        new Date(0) - 0
        ==> 0 - 0
        ==> 0`
    },
    {
        q: `Какой результат у выражения: new Date(0) + 0`,
        a: `    // 'Thu Jan 01 1970 02:00:00 GMT+0200 (EET)0'
        
        Оператор + вызывает преобразование по умолчанию. Объекты типа Data считают таким преобразованием конверсию в строку, в результате используется метод toString(), а не valueOf().

        new Date(0) + 0
        ==> 'Thu Jan 01 1970 02:00:00 GMT+0200 (EET)' + 0
        ==> 'Thu Jan 01 1970 02:00:00 GMT+0200 (EET)0'`
    },
    {
        q:`Расскажите про методологию БЭМ`,
        a: `    БЭМ - блок, элемент, модификатор
        
    Это стандарт, которые говорит о том, как правильно давать имена классам, блокам, элементам

    Названия классов у блоков и элементов, состоящие из нескольких слов, пишутся через тире -
    Например .search-form. Название должно отвечать на вопрос "что это?"
    
    Блок - функционально независимый элемент, который может быть переиспользован несколько раз
    Блоки можно вкладывать друг в друга

    Элемент - это неотъемлемая чать блока, которая не может использоваться в отрыве от него
    Синтаксис элементов следующий:

    имя класса блока__имя класса элемента

    <nav class="menu">
        <a href="#" class="menu__link>
            Ссылка
        </a>
    </nav>
    
    menu - это блок
    menu__link - это элемент блока

    Элементы также можно вкладывать друг в друга. Но название элемента все равно должно ссылаться на блок, в котором они находятся

    Не должно быть такого:
    имя класса блока__имя элемента__имя элемента

    Верная запись:

    <div class="row">
        <div class="row__column">
            <div class="row__item"></div>
        </div>
    </div>
    
    Элемент row__item вложен в элемент row__column, но все равно ссылается на блок row

    Также элемент всегда должен использоваться только внутри блока
    Не должно быть такого:

    <div class="row">
        <div class="row__column">
        </div>
    </div>

    <div class="row__item"></div>

    row__item является частью блока row, но находится за его пределами

    В блоке элементов может не быть, а могут быть только вложенные другие блоки


    Модификатор.

    Дополняет/уточняет стиль блока или элемента

    Имя модификатора должно отвечать на вопрос "какой?".
    Добавляется к имени класса черз одно нижнее подчеркивание

    <nav class="menu">
        <a href="#" class="menu__item menu__item_active">Ссылка1</a>
        <a href="#" class="menu__item">Ссылка2</a>
    </nav>


    Микс.
    Прием, когда объект используем и как блок и как элемент одновременно

    <div class="about">
        <div class="about__title title></div>
        <div class="about__title subtitle></div>
    </div>

    title и subtitle являются и элементом и блоком. В класс title и subtitle пишем универсальные стили, а отступы, размеры уже пишем конкретным элементам about__title и about__title
    `
    },
    {
        q: `Разница между Object.freeze() и const?`,
        a: `    Вообще разные вещи
        
    const - эот переменная, которую нельзя переназначить, нельзя присвоить новое значение
    
    Object.freeze() - замораживает объект, защищает от изменений свойств этого объекта`
    },
    {
        q: `Что такое генераторы? Когда стоит использовать их?`,
        a: `    Генераторы - это новый вид функций в Java Script 
        
    Выполняясь, они могут остановить свое выполнение и вернуть промежуточное значение, а затем обратно продолжить выполняться
    
    Чтобы обычную функцию превратить в генератор, нужно добавить к слову function звездочку *
    
    Внутри функции используется ключевое слово yield
    
    При первом вызове такая функция не выполняет код, а возвращает особый объект - генератор, который позволяет управлять ее выполнением.
    
    Для получения очередного значения, нужно вызвать метод генератора next.
    
    Главное - это то, что получить следующее значение, выдаваемое генератором, мы можем именно тогда, когда нам нужно это в коде`,
        i: 'generators'
    },
    {
        q: `Нужна ли запись import React from 'react' на каждом файле, где используется JSX ?`,
        a: `    Нет, сейчас не нужно. Надпись добавляется только в файле index.js
        
    В старых версиях react нужно было на каждом файле, где используется JSX указывать import, чтобы Babel конвертировал код в JS. 
    
    Сейчас разработчики переработали это и теперь только один раз указываем`
    },
    {
        q: `Можно ли использовать условие if - else внутри фигурных скобок в React ?`,
        a: `    Нет нельзя. Внутри фигурных скобок мы можем использовать только тернарный оператор
        
    function Btn() {
        const text = 'Push me';
        const loged = false;
        
        return <button>{loged ? 'Enter': text}</button>
    }
    

    if - else мы можем использовать отдельно, допустим резатьтат поместить в переменную и уже эту переменную вставить в фигурные скобки`
    },
    {
        q: `Расскажите про элементы и компоненты React`,
        a: `    Компоненты React - это самодостаточные элементы, которые можно использовать на странице любое количество раз. Создавая небольшие фрагменты кода для определенных задач, мы можем использовать их в разных частях приложения по мере его роста
        
    Элементы же - это часть React компонентов

    const elem = <h1>Hello World!</h1>

    
    Компоненты - это по сути функции, которые могут возвращать JSX элементы
    Название компонентов мы пишем с большой буквы.
    
    Пример компонента:
    
    const Header = () => {
        return <h2>Hello world!</h2>
    }
    
    Создали компонент Header
    
    function App() {
        return (
            <div className = 'App';
                <Header/>
            </div>
        );
    }
    
    Компонент Header мы поместили внутрь компонента App
    
    
    Также компоненты могут быть основаны на классах

    class Field extends React.Component {
        render () {
          const holder = 'Your Name';
          const styleField = {
            width: '300px'
          }
          return <input 
                  placeholder={holder} 
                  type="text" 
                  style={styleField}/>
        }
    }
    
    Вначале мы наследуемся от класса React.Component
    
    В классах обязательно должен быть метод render(), который внутри себя может что-либо делать и после этого уже указывается return внутри этого же метода render()`
    },
    {
        q: `Расскажите про StrictMode  в  React`,
        a: `    import React, {StrictMode} from 'react' - говорим, что дополнительно с библиотекой react в отдельную переменную импортируем компонент StrictMode
        
    StrictMode - это инструмент для обнаружения потенциальных проблем в нашем приложении. Он активирует дополнительные проверки для своих потомков
    
    <StrictMode>
        <App/>
    </StrictMode>
    
    При использовании StrictMode react будет нам сообщать, елси мы используем уцстаревший код. Это помогает, в том числе, обнаруживать участки кода с устаревшим синтаксисом и исправлять их на нормальный работающий код
    
    StrictMode работает только в режиме разработки. В режиме продакшн подразумевается, чтовесь код мы уже пофиксили и все раотает правильно`
    },
    {
        q: `Что такое props в React ?`,
        a: `    Props - это данные, котоые мы передаем React компонентам, когда вызываем их
        
    function WhoAmI (props ) {
        return (
            <div>
            <h1>My name is {props.name}, surname - {props.surname}</h1>
            <a href={props.link}>My email</a>
            </div>
        );
    }
    
    function App() {
        return (
          <div className="App">
            <WhoAmI name="Aleh" surname="Shchurko" link="google.com"/>
            <WhoAmI name="Ivan" surname="Abramov" link="facebook.com"/>
          </div>
        );
    }
    
    По сути пропсы - это объект, который хранит в себе атрибуты и их значения
    
    В пропсы мы можем передавать примитивы, можем свойства объектов, функции
    
    Важно помнить, что пропсы используются только для чтения и ни в коем случае не следует их изменять!
    Если нам нужно поменять значение в ответ на пользовательский ввод или ответ сервера, используйем state (состояние)`,
        i: 'props'
    },
    {
        q: `Расскажите про списки, алгоритм согласования и ключи в React`,
        a: `    Когда мы изменяем какой-либо элемент или пропсы, Reacr каждый раз строит новое DOM дерево. Затем он сравнивает элементы нового DOM дерева с элементами в старом DOM дереве и заменяет только те элементы, которые изменились
        
    Этот процесс называется алгоритм согласования. Он служит для оптимизации скорости работы приложения. 
    
    React Обновляет в интерфейсе только те элементы, которые действительно изменились

    При работе со списком одинаковых сущностей используем атрибут "key" для правильной работы алгоритма и сильного ускорения работы приложения

    Суть такова: 
    Каждый раз, когда происходит изменение в состоянии компонента, запускается механизм, именуемый "согласование" (reconciliation), который вычисляет разницу между прошлым состоянием и новым. С алгоритмической точки зрения происходит поиск отличий в двух деревьях. В общем случае алгоритм, выполняющий это вычисление, работает со сложностью O(n3).

    Если события генерируются часто, а виртуальное дерево стало большим, то можно начать замечать лаги невооружённым глазом.

    Для решения этой проблемы React настоятельно просит для всех элементов списков использовать атрибут key, который не меняется для конкретного элемента списка. Подобное требование позволяет оптимизировать работу алгоритма, уменьшив сложность до О(n).
    
    Для чего нужен key:

    Допустим у нас есть некий список 
    
    <ul>
        <li>1</li>
        <li>2</li>
    </ul>

    Допустим нам нужно динамически вставить новый элемент списка в начало

    <ul>
        <li>3</li>
        <li>1</li>
        <li>2</li>
    </ul>

    React будет сравнивать элементы списка по порядку. В старом списке первый элемент был со значением 1, а в новом списке у первого элемента значение 3. Далее, второй элемент в старом списке имеет значение 2, а в новом у второго элемента уже значение 1. И т.д. Т.е. будет заново рендерится весь список, хотя по факту у нас добавился только один элемент, а остальные элементы никак не изменились. А если такие списки огромные, то это займет много времени

    Так вот для того, чтобы неизмененившиеся элементы заново не отрисовывать и нужен уникальный идентификатор key

    <ul>
        <li key: 1>1</li>
        <li key: 2>2</li>
    </ul>

    <ul>
        <li key: 3>3</li>
        <li key: 1>1</li>
        <li key: 2>2</li>
    </ul>

    Теперь react увидит, что жлементы с ключами key:1 и key:2 не изменились и он не будет их изменять, а просто добавит новый элемент с ключом key:3. И это намного быстрее, чем перерисовывать полностю весь список ul`,
        i: 'diff_dom_react'
    },
    {
        q: `Как передавать props в классовых компонентах ?`,
        a: `    Сначала импортируем класс Coponent
        
    import {Component} from 'react';
    
    Затем обращаемся к пропсам этого родительского класса Component через constructor - super. 
    И дальше уже используем их`,
        i: 'props_class_component'
    },
    {
        q: `В чем разница между null и undefined?`,
        a: `    Для начала давайте поговорим о том, что у них общего.

        Во-первых, они принадлежат к 7 «примитивам» (примитивным типам) JS:
        
    let primitiveTypes = ['string', 'number', 'null', 'undefined', 'boolean', 'symbol', 'bigint]
        
    Во-вторых, они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора "!!" является false:

    console.log(!!null) // false
    console.log(!!undefined) // false

    console.log(Boolean(null)) // false
    console.log(Boolean(undefined)) // false

    Ладно, теперь о различиях.

    undefined («неопределенный») представляет собой значение по умолчанию:
    переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
    функции, которая ничего не возвращает явно, например, console.log(1);
    несуществующего свойства объекта.

    null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:

    fs.readFile('path/to/file', (e, data) => {
        console.log(e) // здесь мы получаем null
    if(e) {
        console.log(e)
    }
        console.log(data)
    })

    При сравнении null и undefined мы получаем true, когда используем оператор "==", и false при использовании оператора "===". О том, почему так происходит, см. ниже.

    console.log(null == undefined) // true
    console.log(null === undefined) // false`
    },
    {
        q: `Для чего используется оператор "&&"?`,
        a: `    Оператор "&&" (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. 

        console.log(false && 1 && []) // false
        console.log(' ' && true && 5) // 5`
    },
    {
        q: `Для чего используется оператор "||"?`,
        a: `    Оператор "||" (логическое или) находит и возвращает первое истинное значение
    
    console.log(null || 1 || undefined) // 1

    function logName(name) {
        let n = name || Mark
        console.log(n)
    }
    
    logName() // Mark`
    },
    {
        q: `Является ли использование унарного плюса (оператор "+") самым быстрым способом преобразования строки в число?`,
        a: `    Согласно MDN оператор "+" действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.`
    },
    {
        q: `Что такое всплытие события?`,
        a: `    Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window`
    },
    {
        q: `В чем разница между методами event.preventDefault() и event.stopPropagation()?`,
        a: `    Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение)`
    },
    {
        q: `Как узнать об использовании метода event.preventDefault()?`,
        a: `    Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault`
    },
    {
        q: `Почему obj.someprop.x приводит к ошибке?`,
        a: `    const obj = {}
        console.log(obj.someprop.x)
        
    Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.`
    },
    {
        q: `Что такое цель события или целевой элемент (event.target)?`,
        a: `    Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.

    Имеем такую разметку:
    
    <div onclick="clickFunc(event)" style="text-align: center; margin: 15px;
    border: 1px solid red; border-radius: 3px;">
        <div style="margin: 25px; border: 1px solid royalblue; border-radius: 3px;">
            <div style="margin: 25px; border: 1px solid skyblue; border-radius: 3px;">
                <button style="margin: 10px">
                    Button
                </button>
            </div>
        </div>
    </div>
    
    И такой простенький JS:
    
    function clickFunc(event) {
        console.log(event.target)
    }
    
    Мы прикрепили «слушатель» к внешнему div. Однако если мы нажмем на кнопку, то получим в консоли разметку этой кнопки. Это позволяет сделать вывод, что элементом, вызвавшим событие, является именно кнопка, а не внешний или внутренние div.`
    },
    {
        q: `Что такое текущая цель события (event.currentTarget)?`,
        a: `    Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.

    Аналогичная разметка:
    
    <div onclick="clickFunc(event)" style="text-align: center;margin:15px;
    border:1px solid red;border-radius:3px;">
        <div style="margin: 25px; border:1px solid royalblue;border-radius:3px;">
            <div style="margin:25px;border:1px solid skyblue;border-radius:3px;">
                <button style="margin:10px">
                    Button
                </button>
            </div>
        </div>
    </div>
    
    И немного видоизмененный JS:
    
    function clickFunc(event) {
        console.log(event.currentTarget)
    }
    
    Мы прикрепили слушатель к внешнему div. Куда бы мы ни кликнули, будь то кнопка или один из внутренних div, в консоли мы всегда получим разметку внешнего div. Это позволяет заключить, что event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.`
    },
    {
        q: `Для чего используется оператор "!!"?`,
        a: `    Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.

    console.log(!!null) // false
    console.log(!!undefined) // false
    console.log(!!'') // false
    console.log(!!0) // false
    console.log(!!NaN) // false
    console.log(!!' ') // true
    console.log(!!{}) // true
    console.log(!![]) // true
    console.log(!!1) // true
    console.log(!![].length) // false`
    },
    {
        q: `Как проверить, является ли значение ложным?`,
        a: `    Следует использовать функцию Boolean или оператор "!!" (двойное отрицание)`
    },
    {
        q: `Что такое деструктуризация объекта (Object Destructuring)?`,
        a: `    Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива.

        Допустим, у нас есть такой объект:
        
        const employee = {
            firstName: 'Marko',
            lastName: 'Polo',
            position: 'Software Developer',
            yearHired: 2017
        }
        
    Раньше для получения свойств объекта мы создавали переменные для каждого свойства. Это было очень скучно и сильно раздражало:
    
    var firstName = employee.firstName
    var lastName = employee.lastName
    var position = employee.position
    var yearHired = employee.yearHired
    
    Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки ({ }), а если речь идет о массиве — в квадратные скобки ([ ]):
    
    let { firstName, lastName, position, yearHired } = employee
    
    Для изменения имени переменной следует использовать «propertyName: newName»:
    
    let { firstName: fName, lastName: lName, position, yearHired } = employee
    
    Для присвоения переменным значения по умолчанию следует использовать «propertyName = 'defaultValue'»:
    
    let { firstName = 'Mark', lastName: lName, position, yearHired } = employee`
    },
    {
        q: `Что такое модули (Modules)?`,
        a: `    Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода:

    CommonJS — Nodejs
    AMD (AsyncronousModuleDefinition) — Browsers
    
    Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта`
    },
    {
        q: `Что такое объект Set?`,
        a: `    Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue.

    Экземпляр Set создается с помощью конструктора Set. Мы также можем передать ему некоторые значения при создании:
    
    const set1 = new Set()
    const set2 = new Set(['a','b','c','d','d','e']) // вторая "d" не добавится
    
    Мы можем добавлять значения в Set, используя метод add. Поскольку метод add является возвращаемым, мы может использовать цепочку вызовов:
    
    set2.add('f')
    set2.add('g').add('h').add('i').add('j').add('k').add('k') // вторая "k" не добавится
    
    Мы можем удалять значения из Set, используя метод delete:
    
    set2.delete('k') // true
    set2.delete('z') // false, потому что в set2 нет такого значения
    
    Мы можем проверить наличие свойства в Set, используя метод has:
    
    set2.has('a') // true
    set2.has('z') // false
    
    Для получения длины Set используется метод size:
    
    set2.size // 10
    
    Метод clear очищает Set:
    
    set2.clear() // пусто
    
    Мы можем использовать Set для удаления повторяющихся значений в массиве:
    
    const nums = [1,2,3,4,5,6,6,7,8,8,5]
    const uniqNums = [...new Set(nums)] // [1,2,3,4,5,6,7,8]`
    },
    {
        q: `Что такое функция обратного вызова (Callback Function)?`,
        a: `    Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события).

    const btnAdd = document.getElementById('btnAdd')
    
    btnAdd.addEventListener('click', function clickCallback(e)){
        // делаем нечто полезное
    }
    
    В примере мы ждем события «клик» на элементе с идентификатором «btnAdd». По клику вызывается функция clickCallback. Функция обратного вызова добавляет некоторый функционал данным или событию. Методам reduce, filter и map в качестве второго аргумента передается функция обратного вызова. Хорошей аналогией callback является следующая ситуация: Вы звоните кому-то, он не отвечает, Вы оставляете ему сообщение и ждете, когда он перезвонит. Звонок или сообщение — это событие или данные, а callback — это ожидание (предвосхищение) встречного звонка.`
    },
    {
        q: `В чем разница между методами Object.freeze и Object.seal?`,
        a: `    Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется`
    },
    {
        q: `В чем разница между оператором «in» и методом hasOwnProperty?`,
        a: `    Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

    console.log('prop' in o) // true
    console.log('toString' in o) // true
    
    console.log(o.hasOwnProperty('prop')) // true
    console.log(o.hasOwnProperty('toString')) // false`
    },
    {
        q: `Почему typeof null возвращает object? Как проверить, является ли значение null?`,
        a: `    typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок).

    Для проверки, является ли значение null можно использовать оператор строгого равенства (===):
    
    function isNull(value){
        return value === null
    }`
    }
    
];

searchQuestion();

function searchQuestion() {
    num = Math.floor(Math.random() * arr.length);
    if(arr[num] === null) {
        searchQuestion();
    } else {
        question.innerText = arr[num].q;
        // question.innerText = arr[4].q;
        console.log(arr[num]);

        answerBtn.addEventListener('click', showAnswer);

        nextQuestionBtn.addEventListener('click', next);
    }
    
}

function showAnswer() {
    answer.innerText = arr[num].a;

    if (arr[num].hasOwnProperty('i')) {
        newImg = document.createElement('img');
        newImg.src = `img/${arr[num].i}.jpg`;
        newImg.style.cssText = 'width: 100%; object-fit: contain; margin: 0 auto; padding-top: 10px';
        
        answerBlock.append(newImg);
    }
    arr[num] = null;
    answerBtn.removeEventListener('click', showAnswer)
}

function next() {
    arr[num] = null;
    if (answerBlock.children.length > 1) {
    answerBlock.removeChild(newImg);
    }
    answer.innerText = '';

    let flag = arr.every(elem => {
        return elem === null;
    });

    if (flag) {
        clear();
    } else {
        searchQuestion();
    }
}

function clear() {
    question.innerText = 'Вы прошли все вопросы';
    answer.innerText = '';

    answerBtn.removeEventListener('click', showAnswer);
    nextQuestionBtn.removeEventListener('click', next);
}

