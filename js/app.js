let question = document.querySelector('.pre_q');
let answer = document.querySelector('.pre_a');
let answerBtn = document.querySelector('.answer_btn');
let nextQuestionBtn = document.querySelector('.quest_btn');
let answerBlock = document.querySelector('.answer');
let num= 0;
let newImg;


let arr = [
    {
        q: 'Что такое Doctype? Для чего он используется?',
        a: `    Doctype используется для указания типа документа. Он добавляется первой строкой любого HTML документа.

    Служит для того, чтобы браузер мог понять, как ему интерпретировать страницу и в соответствии с каким стандартом парсить страницу`
    },
    {
        q: 'Базовая структура HTML страницы?',
        a: `    Первой строкой обязательно указывается Doctype

    <!DOCTYPE html>

    Затем тег <HTML> - контейнер, в котором содержится все содержимое страницы

    <html lang = 'en'>
    
    Далее тег <head>. Он содержит в себе все необходимые данные о HTML странице (заголовок, описание, SEO информация, подключение стилей,шрифтов)

    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    
    Далее <body>- Содержит в себе всю разметку HTML страницы. Здесь вся видимая часть страницы

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    <body>
    </body>
    </hed>
    </html>`
    },
    {
        q: `Что такое семантика? Какие семантические теги вы знаете?`,
        a: `    Семантика в HTML - это использование правильных тегов, которые описывают содержание контента внутри себя.
        
    Семантичный тег - это тег, который обладает каким-то пояснением своего предназначения.
    
    По тегу должно быть понятно, что внутри него находится.
    
    <header></header> - Шапка сайта

    <footer></footer> - подвал

    <aside></aside> - боковая панель

    <nav></nav> - навигация по сайту

    <main></main> - основное содержимое документа

    <p></p> - параграф

    <h1></h1> - заголовок

    <em></em> - курсив с семантикой

    <strong></strong> - жирный текст с семантикой

    <ul></ul> - маркированный список и т.д.`
    },
    {
        q: `Какая разница между тегами <strong>, <em> и <b>, <i>`,
        a: `    <strong> и <em> предназначены для придания элементу логического выделения.
        
    При чтении страницы поисковыми роботами или screen- ридарами на этих элементах будет сделан акцент`
    },
    {
        q: `Разница между call, apply и bind?`,
        a: `    Из-за запутанности кода может случиться ситуация, когда контекст this будет ссылаться не на тот объект, что нам нужен.
    
    Мы можем сами задать, на какой объект будет ссылаться this в определенной функции.
    
    function showName(firstName, lastName) {
        console.log(firstName + ' ' + lastName)
    }
    
    const user = {
        firstName: 'Ivan',
        lastName: 'Petrov'
    }
    
    Теперь указываем, для функции showName, что this внутри нее должен ссылаться на объукт user.
    
    Для этого есть 3 способа:
    
    call
    
    showName.call(user, 'firstName', 'lastName) - функция showName сразу же вызовется и отработает
    
    apply

    showName.apply(user, ['firstName', 'lastName]) - функция showName сразу же вызовется и отработает

    В call параметры функции записываются через запятые, ихможет быть сколько угодно.
    А в apply может быть только два параметра. Поэтому первый параметр - это всегда объект, а остальные параметры просто записываются внутри массива.

    bind

    showName.bind(user, 'firstName', 'lastName)()

    Параметры также как и в call записфваются через запятую. Но bind не вызывается сразу. Т.е. мы можем передать контекст, а функцию уже вызвать тогда, когда нам это нужно. Либо, если нужно сразу вызвать, то в конце указываем скобки ()`,
    i: 'apply'
    },
    {
        q: 'Что такое делигирование событий?',
        a: `    Делигирование - это прием разработки, когда вместо того, чтобы вешать кучу однотипных обработчиков событий на все элементы, можно добавить всего лишь один обработчик на общего родителя.

    Например: мы создаем таблицу и нам нужно, чтобы при нажатии на ячейку она закрашивалась в какой-либо цвет. Мы не вешаем обработчики на каждую ячейку (ячеек может быть и тысячи, тогда нам понадобятся тысячи обработчиков). Мы вешаем всего один обработчик на саму таблицу. 

    Далее мы просто указываем, что если элемента, по которому мы кликнули - это ячейка, то она должна закраситься нужным цветом`,
    i: 'delegation'
    },
    {
        q: `Что такое CSS и для чего он используется?`,
        a: `    CSS - расшифровывается как каскадня таблица стилей. Предназначена она для для добавления различных стилей на HTML страницу.
        
    На CSS лежит задача добавления на страницу различных визуальных эффектов.
    
    Каскадная- означает, что мы можем подключать стили одновременно несколькими способами и все они будут работать.
    
    Наследование в CSS - означает, что если не указано иное, то конкретный стиль будет унаследован всеми такими же элементами, а также стиль будет применятся ко всем дочерним элементам. 
    
    Например, если мы добавим background-color к div, то все div на страницы изменят цвет и все вложенные элементы в этих div-ах также изменят цвет`
    },
    {
        q: `Варианты добавления CSS стилей на страницу?`,
        a: `    Есть 4 способа: 

    1. <div style="background-color: red></div>
    
    Добавляем стиль конкретному элементу прямо в его теге
    
    2. <head>
            <style>
                div {background-color: red}
            </style>
        </head>
        
    Добавляем стиль в тег <head> к определенным элементам
    
    3. <head>
            <link rel="stylesheet" href="css/style.css">
        </head>
        
    Прикрепляем CSS- файл
    
    4. @import "style/media.css"
        @import "style/footer.css"
       
    Импорты внутри файлов стилей`
    },
    {
        q: `Типы позиционирования в CSS`,
        a: `    Существует 5 типов позиционирования в CSS
        
    1. Static - устанавливается элементам по умолчанию
    
    2. Relative - элемент позиционируется относительно своего текущего положения
    
    3. Absolute - позиционирование отнрсительно другого элемента, у которого позиционирование не Static.
       Если такого элемента нет, то относительно окна браузера

    4. Fixed - позиционирование только относительно окна браузера
    
    5. Sticky - в видимой части экрана элемент ведет себя как fixed. При дальнейшей прокрутке скроллится вместе с родителем`
    },
    {
        q: `Блочная модель CSS?`,
        a: `    Блочная модель позволяет посчитать, какое итоговое пространство будет занимать элемент на странице.
    
    В нее входит:
    
    - сам контент
    
    - padding
    
    - border
    
    - margin
    
    Общий размер элемента- это сумма этих размеров.
    
    Если нам нужно, чтобы размер элемента являлся заданному значению, то используем команду:
    
    box-sizing: border-box
    `,
    i: 'block_model_css'
    },
    {
        q: `Типы данных в CSS?`,
        a: `    В Java Script существует 8 типов данных
        
    1. String
    
    2. Number
    
    3. Bigint
    
    4. Boolean
    
    5. Symbol
    
    6. Object
    
    7. Null
    
    8. Undefined`
    },
    {
        q: `Строгий режим Strict Mode в Java Script?`,
        a: `    Строгий режим позволяет использовать более строгий вариант JS синтаксиса.
        
    Заменяет исключениями некоторые ошибки, которые интерпретатор JS раньше пропускал.
    Более опасные и не полезные черты JS теперь запрещены или приводят к ошибке
    
    Как подключить?

    1. "use strict"

    2. function func() {
            "use strict"
        }

    Строгий режим будет работать только внутри функции

    3. В ES-6 режим добавляется автоматически`
    },
    {
        q: `Какая разница между function declaration и function expression?`,
        a: `    function declaration

    function sum(a,b) {
        return a + b
    }
    
    function expression
    
    let sum = funcrion(a,b) {
        return a + b
    }
    
    function declaration можно вызывать до ее объявления, а function expression нельзя`
    },
    {
        q: `Что такое валидация? Типы проверок HTML - документа?`,
        a: `    Валидация - это проверка документа специальной программой - валидатором на соответствие установленным web стандартам и на обнаружение существующих ошибок.
    
    Эти стандарты называются спецификациями.
    
    Валидатор сначала определяет тип документа, который указывается с помощью Doctype.
    
    Затем проверяет HTML код на правильность и отсутствие ошибок. При этом проверяется правильность имен тегов и их вложенность.
    
    Проверить валидность можно на сайте:
    
    http://validator.w3.org`
    },
    {
        q: `Какой тег использовать, чтобы сверстать кнопку?`,
        a: `    Сразу нужно уточнить, а какая именно кнопка нужна.
        
    1. <button>Нажми</button> - обычная кнопка
    
    2. Кнопки подтверждения формы
    
    <button type="submit">Отправить</button>
    <input type="submit" value="button>
    
    3. <input type="button"> - устаревающий способ
    
    4. <a href="#">Button</a> - кнопка - ссылка. Дальше придаем стили, чтобы чтилизоват ее под кнопку`
    },
    {
        q: `Что такое инлайновый стиль? Можно ли его переопределить?`,
        a: `    Инлайновый стиль - это стиль, примененный к определенному элементу непосредственно в его теге в HTML.
        
    Переопределить его можно с помощью директивы !importmant
    
    <div style="text-align:center"></div>
    
    Чтобы перезаписать его (переопределить) вешаем !importmant на CSS свойство
    
    <style>
        div{text-align:left !importmant}
    </style>`
    },
    {
        q: `Что такое селектор? Какие селекторы существуют?`,
        a: `    Селектор - это часть CSS правила ,которая сообщает браузеру, к какому элементу или элементам web страницы будет применен стиль.
        
    Все селекторы делятся на 2 группы
    
    1. Простые
    
    - .class
    
    - #id
    
    - p (тег)
    
     - * (универсальный селектор. Ставим * и дальше описываются правила(имя, класс и т.д.). Т.е. помогает выбрать абсолютно любой элемент со страницы)
     
     - a[href="text]
     
     2. Составные
     
     - h1, h2, span - перечисляем через запятую
     
     - div p - челектор потомка. Через пробел. Указывать можем всю цепочку воженности
     
     - li > a - селектор только дочернего элемента
     
     - a:hover - селектор псевдокласса
     
     - li:nth-last-child(2n) - селектор псевдоэлемента`
    },
    {
        q:`Что такое специфичность селектора? Как считать вес селектора?`,
        a: `    Специфичность - это способ, с помощью которого брацзер определяет, какие значения CSS свойств будут применены к элементу.
        
    Если на элементе висит сразу несколько свойств, повешенных разными способами, то нужно определить, какое из этих свойств будет применяться`
    },
    {
        q: `Разница между Reset.css и Normalize.css?`,
        a: `    Все HTML элементы обладают дефолтными стилями. И в разных браузерах эти стили разные.
        
    Чтобы во всех браузерах контент выглядел одинаково, перед тем как начинать верстку используют эти два метода.
    
    По сути это CSS файл, который подключается в самом начале доумента.
    
    1. Reset - сбрасывает все стили и их нужно прописовать заново
    
    2. Normalize - прописываем стили, которые должны будут применяться везде одинаково`
    },
    {
        q: `Что такое поднятие (hoisting)?`,
        a: `    Hoisting - это механизм подъема функции или переменной в глобальную или функциональную область видимости
        
    Java Script сначала объявляет, а затем инициализирует переменные.
    
    Переменные, объявленные через var и функции function declaration можно использовать еще до объявления их значений.
    
    Если function declaration мы можем объявить хоть в самом конце кода, то с var работает не так.
    
    Hoisting работает с объявлением, но инициализация будет только в момент присваивания значения.
    
    Т.е. объявить-то var мы можем в самом конце кода, но пока мы не передадим ей какое - либо значение, переменная через var при обращении к ней будет выдавать undefined
    
    А переменные, объявленные через let и const при обращении к ним до их объявления будут выводить не undefined а ошибку
    
    console.log(a); // undefined
    var a = 20;`
    },
    {
        q: `Типы таймеров в Java Script?`,
        a: `    Есть 2 типа таймеров
    1. setTimeout() - вызывает переданную функцию один раз через указанный промежуток времени

    2. setInterval - будет вызывать функцию постоянно через указанные промежутки времени
    
    clearTimeout - позволяет остановить setTimeout до его вызова
    
    clearInterval - позволяет остановить setInterval. Перед этим setInterval записываем в переменную и ее передаем параметром в clearInterval`
    },
    {
        q: `Типы списков в HTML?`,
        a: `    Есть 3 типа списков
    1. Маркированный <ul></ul>
    
    2. Нумерованный <ol></ol>
    
    3. Список определений 
    
    <dl>
        <dt>Определение</dt>
        <dd>Поясняющий текст</dd>
    </dl>`
    },
    {
        q: `Как семантически правильно сверстать картинку с подписью?`,
        a: `    Нужно использовать сначала тег <figure>

    <figure><img><figcaption>Поясняющий текст</figcaption></figure>

    При этом использование этих тегов не отменяет того, что внутри тега <img> нужно указывать alt

    Перед пояснением <figcaption> может идти несколько изображений и тогда пояснение будет одно для них` 
    },
    {
        q: `Разница между display:none и visibility:hidden?`,
        a: `    Оба правила предназначены для того, чтобы скрывать элемент на странице.
        
    display:none - полностью убирает элемент с HTML страницы. Единственное место, где он останется - это DOM дерево
    
    Контент внутри скрытого таким образом блока становится недоступно для поисковых роботов
    
    visibility:hidden - на HTML странице элемент становится не виден, но из основного потока он не вырывается и по прежнему занимает отведенное для него место. А также он остается доступен для поисковых роботов`
    },
    {
        q: `Разница между блочными и строчными (инлайновыми) элементами?`,
        a: `    Основная разница между блочными и строчными элементами в том, что по умолчанию блочный элемент будет занимать всю ширину экрана, а строчнй элемент имеет ширину его содержимого.
        
    Поэтому блочные элементы идут друг под другом, а строчные в одну линию.
    
    Также блочным элементам можно задавать размеры (ширину и высоту), а для строчных это не работает.
    
    Блочные элементы воспринимают margin и padding, а для строчных элементов margin сверху и снизу не работает`
    },
    {
        q: `Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?`,
        a: `    Адаптивный дизайн - это по сути несколько версий одного и того же сайта, которые загружаются пользователю в зависимости от устройства, на котором открыт сайт.
    Пользователь заходит на сайт, браузер определяет тип устройства, с которого пользователь зашел и отправляет его на специально разработанную для этого устройства версию сайта.
        
    Responsive - это один и тот же дизайн, который автоматически сжимается в зависимости от ширины экрана`
    }

];

searchQuestion();

function searchQuestion() {
    num = Math.floor(Math.random() * arr.length);
    if(arr[num] === null) {
        searchQuestion();
    } else {
        question.innerText = arr[num].q;
        // question.innerText = arr[4].q;
        console.log(arr[num]);

        answerBtn.addEventListener('click', showAnswer);

        nextQuestionBtn.addEventListener('click', next);
    }
    
}

function showAnswer() {
    answer.innerText = arr[num].a;

    if (arr[num].hasOwnProperty('i')) {
        newImg = document.createElement('img');
        newImg.src = `./img/${arr[num].i}.jpg`;
        newImg.style.cssText = 'width: 100%; object-fit: contain; margin: 0 auto; padding-top: 10px';
        
        answerBlock.append(newImg);
    }

    arr[num] = null;
}

function next() {
    arr[num] = null;
    if (answerBlock.children.length > 1) {
    answerBlock.removeChild(newImg);
    }
    answer.innerText = '';

    let flag = arr.every(elem => {
        return elem === null;
    });

    if (flag) {
        clear();
    } else {
        searchQuestion();
    }
}

function clear() {
    question.innerText = 'Вы прошли все вопросы';
    answer.innerText = '';

    answerBtn.removeEventListener('click', showAnswer);
    nextQuestionBtn.removeEventListener('click', next);
}

