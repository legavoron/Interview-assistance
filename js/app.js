let question = document.querySelector('.pre_q');
let answer = document.querySelector('.pre_a');
let answerBtn = document.querySelector('.answer_btn');
let nextQuestionBtn = document.querySelector('.quest_btn');
let answerBlock = document.querySelector('.answer');
let num= 0;
let newImg;


let arr = [
    {
        q: 'Что такое Doctype? Для чего он используется?',
        a: `    Doctype используется для указания типа документа. Он добавляется первой строкой любого HTML документа.

    Служит для того, чтобы браузер мог понять, как ему интерпретировать страницу и в соответствии с каким стандартом парсить страницу`
    },
    {
        q: 'Базовая структура HTML страницы?',
        a: `    Первой строкой обязательно указывается Doctype

    <!DOCTYPE html>

    Затем тег <HTML> - контейнер, в котором содержится все содержимое страницы

    <html lang = 'en'>
    
    Далее тег <head>. Он содержит в себе все необходимые данные о HTML странице (заголовок, описание, SEO информация, подключение стилей,шрифтов)

    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    
    Далее <body>- Содержит в себе всю разметку HTML страницы. Здесь вся видимая часть страницы

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    <body>
    </body>
    </hed>
    </html>`
    },
    {
        q: `Что такое семантика? Какие семантические теги вы знаете?`,
        a: `    Семантика в HTML - это использование правильных тегов, которые описывают содержание контента внутри себя.
        
    Семантичный тег - это тег, который обладает каким-то пояснением своего предназначения.
    
    По тегу должно быть понятно, что внутри него находится.
    
    <header></header> - Шапка сайта

    <footer></footer> - подвал

    <aside></aside> - боковая панель

    <nav></nav> - навигация по сайту

    <main></main> - основное содержимое документа

    <p></p> - параграф

    <h1></h1> - заголовок

    <em></em> - курсив с семантикой

    <strong></strong> - жирный текст с семантикой

    <ul></ul> - маркированный список и т.д.`
    },
    {
        q: `Какая разница между тегами <strong>, <em> и <b>, <i>`,
        a: `    <strong> и <em> предназначены для придания элементу логического выделения.
        
    При чтении страницы поисковыми роботами или screen- ридарами на этих элементах будет сделан акцент`
    },
    {
        q: `Разница между call, apply и bind?`,
        a: `    Из-за запутанности кода может случиться ситуация, когда контекст this будет ссылаться не на тот объект, что нам нужен.
    
    Мы можем сами задать, на какой объект будет ссылаться this в определенной функции.
    
    function showName(firstName, lastName) {
        console.log(firstName + ' ' + lastName)
    }
    
    const user = {
        firstName: 'Ivan',
        lastName: 'Petrov'
    }
    
    Теперь указываем, для функции showName, что this внутри нее должен ссылаться на объукт user.
    
    Для этого есть 3 способа:
    
    call
    
    showName.call(user, 'firstName', 'lastName) - функция showName сразу же вызовется и отработает
    
    apply

    showName.apply(user, ['firstName', 'lastName]) - функция showName сразу же вызовется и отработает

    В call параметры функции записываются через запятые, ихможет быть сколько угодно.
    А в apply может быть только два параметра. Поэтому первый параметр - это всегда объект, а остальные параметры просто записываются внутри массива.

    bind

    showName.bind(user, 'firstName', 'lastName)()

    Параметры также как и в call записфваются через запятую. Но bind не вызывается сразу. Т.е. мы можем передать контекст, а функцию уже вызвать тогда, когда нам это нужно. Либо, если нужно сразу вызвать, то в конце указываем скобки ()`,
    i: 'apply'
    },
    {
        q: 'Что такое делигирование событий?',
        a: `    Делигирование - это прием разработки, когда вместо того, чтобы вешать кучу однотипных обработчиков событий на все элементы, можно добавить всего лишь один обработчик на общего родителя.

    Например: мы создаем таблицу и нам нужно, чтобы при нажатии на ячейку она закрашивалась в какой-либо цвет. Мы не вешаем обработчики на каждую ячейку (ячеек может быть и тысячи, тогда нам понадобятся тысячи обработчиков). Мы вешаем всего один обработчик на саму таблицу. 

    Далее мы просто указываем, что если элемента, по которому мы кликнули - это ячейка, то она должна закраситься нужным цветом`,
    i: 'delegation'
    },
    {
        q: `Что такое CSS и для чего он используется?`,
        a: `    CSS - расшифровывается как каскадня таблица стилей. Предназначена она для для добавления различных стилей на HTML страницу.
        
    На CSS лежит задача добавления на страницу различных визуальных эффектов.
    
    Каскадная- означает, что мы можем подключать стили одновременно несколькими способами и все они будут работать.
    
    Наследование в CSS - означает, что если не указано иное, то конкретный стиль будет унаследован всеми такими же элементами, а также стиль будет применятся ко всем дочерним элементам. 
    
    Например, если мы добавим background-color к div, то все div на страницы изменят цвет и все вложенные элементы в этих div-ах также изменят цвет`
    },
    {
        q: `Варианты добавления CSS стилей на страницу?`,
        a: `    Есть 4 способа: 

    1. <div style="background-color: red></div>
    
    Добавляем стиль конкретному элементу прямо в его теге
    
    2. <head>
            <style>
                div {background-color: red}
            </style>
        </head>
        
    Добавляем стиль в тег <head> к определенным элементам
    
    3. <head>
            <link rel="stylesheet" href="css/style.css">
        </head>
        
    Прикрепляем CSS- файл
    
    4. @import "style/media.css"
        @import "style/footer.css"
       
    Импорты внутри файлов стилей`
    },
    {
        q: `Типы позиционирования в CSS`,
        a: `    Существует 5 типов позиционирования в CSS
        
    1. Static - устанавливается элементам по умолчанию
    
    2. Relative - элемент позиционируется относительно своего текущего положения
    
    3. Absolute - позиционирование отнрсительно другого элемента, у которого позиционирование не Static.
       Если такого элемента нет, то относительно окна браузера

    4. Fixed - позиционирование только относительно окна браузера
    
    5. Sticky - в видимой части экрана элемент ведет себя как fixed. При дальнейшей прокрутке скроллится вместе с родителем`
    },
    {
        q: `Блочная модель CSS?`,
        a: `    Блочная модель позволяет посчитать, какое итоговое пространство будет занимать элемент на странице.
    
    В нее входит:
    
    - сам контент
    
    - padding
    
    - border
    
    - margin
    
    Общий размер элемента- это сумма этих размеров.
    
    Если нам нужно, чтобы размер элемента являлся заданному значению, то используем команду:
    
    box-sizing: border-box
    `,
    i: 'block_model_css'
    },
    {
        q: `Типы данных в CSS?`,
        a: `    В Java Script существует 8 типов данных
        
    1. String
    
    2. Number
    
    3. Bigint
    
    4. Boolean
    
    5. Symbol
    
    6. Object
    
    7. Null
    
    8. Undefined`
    },
    {
        q: `Строгий режим Strict Mode в Java Script?`,
        a: `    Строгий режим позволяет использовать более строгий вариант JS синтаксиса.
        
    Заменяет исключениями некоторые ошибки, которые интерпретатор JS раньше пропускал.
    Более опасные и не полезные черты JS теперь запрещены или приводят к ошибке
    
    Как подключить?

    1. "use strict"

    2. function func() {
            "use strict"
        }

    Строгий режим будет работать только внутри функции

    3. В ES-6 режим добавляется автоматически`
    },
    {
        q: `Какая разница между function declaration и function expression?`,
        a: `    function declaration

    function sum(a,b) {
        return a + b
    }
    
    function expression
    
    let sum = funcrion(a,b) {
        return a + b
    }
    
    function declaration можно вызывать до ее объявления, а function expression нельзя`
    },
    {
        q: `Что такое валидация? Типы проверок HTML - документа?`,
        a: `    Валидация - это проверка документа специальной программой - валидатором на соответствие установленным web стандартам и на обнаружение существующих ошибок.
    
    Эти стандарты называются спецификациями.
    
    Валидатор сначала определяет тип документа, который указывается с помощью Doctype.
    
    Затем проверяет HTML код на правильность и отсутствие ошибок. При этом проверяется правильность имен тегов и их вложенность.
    
    Проверить валидность можно на сайте:
    
    http://validator.w3.org`
    },
    {
        q: `Какой тег использовать, чтобы сверстать кнопку?`,
        a: `    Сразу нужно уточнить, а какая именно кнопка нужна.
        
    1. <button>Нажми</button> - обычная кнопка
    
    2. Кнопки подтверждения формы
    
    <button type="submit">Отправить</button>
    <input type="submit" value="button>
    
    3. <input type="button"> - устаревающий способ
    
    4. <a href="#">Button</a> - кнопка - ссылка. Дальше придаем стили, чтобы чтилизоват ее под кнопку`
    },
    {
        q: `Что такое инлайновый стиль? Можно ли его переопределить?`,
        a: `    Инлайновый стиль - это стиль, примененный к определенному элементу непосредственно в его теге в HTML.
        
    Переопределить его можно с помощью директивы !importmant
    
    <div style="text-align:center"></div>
    
    Чтобы перезаписать его (переопределить) вешаем !importmant на CSS свойство
    
    <style>
        div{text-align:left !importmant}
    </style>`
    },
    {
        q: `Что такое селектор? Какие селекторы существуют?`,
        a: `    Селектор - это часть CSS правила ,которая сообщает браузеру, к какому элементу или элементам web страницы будет применен стиль.
        
    Все селекторы делятся на 2 группы
    
    1. Простые
    
    - .class
    
    - #id
    
    - p (тег)
    
     - * (универсальный селектор. Ставим * и дальше описываются правила(имя, класс и т.д.). Т.е. помогает выбрать абсолютно любой элемент со страницы)
     
     - a[href="text]
     
     2. Составные
     
     - h1, h2, span - перечисляем через запятую
     
     - div p - челектор потомка. Через пробел. Указывать можем всю цепочку воженности
     
     - li > a - селектор только дочернего элемента
     
     - a:hover - селектор псевдокласса
     
     - li:nth-last-child(2n) - селектор псевдоэлемента`
    },
    {
        q:`Что такое специфичность селектора? Как считать вес селектора?`,
        a: `    Специфичность - это способ, с помощью которого брацзер определяет, какие значения CSS свойств будут применены к элементу.
        
    Если на элементе висит сразу несколько свойств, повешенных разными способами, то нужно определить, какое из этих свойств будет применяться`
    },
    {
        q: `Разница между Reset.css и Normalize.css?`,
        a: `    Все HTML элементы обладают дефолтными стилями. И в разных браузерах эти стили разные.
        
    Чтобы во всех браузерах контент выглядел одинаково, перед тем как начинать верстку используют эти два метода.
    
    По сути это CSS файл, который подключается в самом начале доумента.
    
    1. Reset - сбрасывает все стили и их нужно прописовать заново
    
    2. Normalize - прописываем стили, которые должны будут применяться везде одинаково`
    },
    {
        q: `Что такое поднятие (hoisting)?`,
        a: `    Hoisting - это механизм подъема функции или переменной в глобальную или функциональную область видимости
        
    Java Script сначала объявляет, а затем инициализирует переменные.
    
    Переменные, объявленные через var и функции function declaration можно использовать еще до объявления их значений.
    
    Если function declaration мы можем объявить хоть в самом конце кода, то с var работает не так.
    
    Hoisting работает с объявлением, но инициализация будет только в момент присваивания значения.
    
    Т.е. объявить-то var мы можем в самом конце кода, но пока мы не передадим ей какое - либо значение, переменная через var при обращении к ней будет выдавать undefined
    
    А переменные, объявленные через let и const при обращении к ним до их объявления будут выводить не undefined а ошибку
    
    console.log(a); // undefined
    var a = 20;`
    },
    {
        q: `Типы таймеров в Java Script?`,
        a: `    Есть 2 типа таймеров
    1. setTimeout() - вызывает переданную функцию один раз через указанный промежуток времени

    2. setInterval - будет вызывать функцию постоянно через указанные промежутки времени
    
    clearTimeout - позволяет остановить setTimeout до его вызова
    
    clearInterval - позволяет остановить setInterval. Перед этим setInterval записываем в переменную и ее передаем параметром в clearInterval`
    },
    {
        q: `Типы списков в HTML?`,
        a: `    Есть 3 типа списков
    1. Маркированный <ul></ul>
    
    2. Нумерованный <ol></ol>
    
    3. Список определений 
    
    <dl>
        <dt>Определение</dt>
        <dd>Поясняющий текст</dd>
    </dl>`
    },
    {
        q: `Как семантически правильно сверстать картинку с подписью?`,
        a: `    Нужно использовать сначала тег <figure>

    <figure><img><figcaption>Поясняющий текст</figcaption></figure>

    При этом использование этих тегов не отменяет того, что внутри тега <img> нужно указывать alt

    Перед пояснением <figcaption> может идти несколько изображений и тогда пояснение будет одно для них` 
    },
    {
        q: `Разница между display:none и visibility:hidden?`,
        a: `    Оба правила предназначены для того, чтобы скрывать элемент на странице.
        
    display:none - полностью убирает элемент с HTML страницы. Единственное место, где он останется - это DOM дерево
    
    Контент внутри скрытого таким образом блока становится недоступно для поисковых роботов
    
    visibility:hidden - на HTML странице элемент становится не виден, но из основного потока он не вырывается и по прежнему занимает отведенное для него место. А также он остается доступен для поисковых роботов`
    },
    {
        q: `Разница между блочными и строчными (инлайновыми) элементами?`,
        a: `    Основная разница между блочными и строчными элементами в том, что по умолчанию блочный элемент будет занимать всю ширину экрана, а строчнй элемент имеет ширину его содержимого.
        
    Поэтому блочные элементы идут друг под другом, а строчные в одну линию.
    
    Также блочным элементам можно задавать размеры (ширину и высоту), а для строчных это не работает.
    
    Блочные элементы воспринимают margin и padding, а для строчных элементов margin сверху и снизу не работает`
    },
    {
        q: `Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?`,
        a: `    Адаптивный дизайн - это по сути несколько версий одного и того же сайта, которые загружаются пользователю в зависимости от устройства, на котором открыт сайт.
    Пользователь заходит на сайт, браузер определяет тип устройства, с которого пользователь зашел и отправляет его на специально разработанную для этого устройства версию сайта.
        
    Responsive - это один и тот же дизайн, который автоматически сжимается в зависимости от ширины экрана`
    },
    {
        q: `Что такое область видимости (scope)?`,
        a: `    Область видимости или scope - это место, откуда мы имеем доступ к переменным или функциям.
    В JS есть 3 типа областей видимости:
    
    1. Глобальная
    
    2. Функциональная - переменные и функции, объявленные внутри функции доступны только внутри это  функции и всем ее вложенностям
    
    3. Блочная - новая область видимости, которая появилась в ES-6 для переменных, объявленных через let и const
    
    Это область видимости, которая находится между фигурными скобками {}, так называемого блока. Это например (if... else, цикл for)
    
    Переменные, объявленные через var такую область видимости игнорируют. Т.е. если мы внутри if ... else объявим переменную через var, то она просто станет глобальной`
    },
    {
        q: `Разница между var, let и  const`,
        a: `    var - подвержены всплытию. Если мы обратимся к переменной, объявленной через var до присваивания ей значения (до ее инициализации), то получим просто undefined, а у let и const в таком случаем нам выведет ошибку
        
    У let и const область видимости ограничена блоком, т.е. фигурными скобками. У var область видимости ограничена только функцией
    
    Если let и const объявлены внутри фигурных скобок, то они доступны только внутри них и на всех вложенных уровнях
    
    Переменная, объявленная через var такую область видимости игноририрует и может быть видна за ее пределами
    
    const - невозможно переопределить, т.е. нельзя присвоит ей новое значение`
    },
    {
        q: `Что такое функции высшего порядка?`,
        a: `    Функции высшего порядка - это функции, которые возвращают другие функции или же принимают другую ункцию в качестве аргумента
        
    Например: 
    
    let higherOrderFunction = (params, callback) => {
        return callback(params)
    }
    
    К ним относятся такие функции (методы) как :
    
    - map;
    
    - filter
    
    - forEach и т.д.`
    },
    {
        q: `Что такое DOM?`,
        a: `    DOM - это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML кода
        
    Если просто, HTML - это текст, а DOM - это набор связанных объектов, которые создает браузер при парсинге этого текста
    
    Каждый объект соответствует каждому тегу и они вложены друг в друга, как и теги в HTML. Вложенность похожа на форму дерева - поэтому называется DOM- дерево`
    },
    {
        q: `Что такое распространение события (event propogation)?`,
        a: `    Распространение события - это механизм, который отрабатывает когда какое-либо событие происходит в документе
        
    События распространяются от объекта window до вызывающего его элемента. При этом событие последовательно затрагивает всех предков целевого документа
    
    Есть 3 основные фазы распространения событий:
    
    1. capture - событие проходит от корня документа по DOM дереву до целевого элемента. Это фаза захвата
    
    2. target - событие достигает целевого элемента. Обычно его называют event target
    
    3. bubbling - всплытие. Событие возвращается обратно до window, паралельно вызывая все события на родительских элементах`
    },
    {
        q: `Что такое HTML и для чего он используется?`,
        a: `    HTML - это язык гипертекстовой разметки, позволяющий составлять форматированный текст
        
    Данный текст интерпретируется браузером. После чего браузер отображает этот текст на экране в виде элементов web- страницы

    По сути это скелет или каркас любой web- страницы, содержащий разметку

    Основная задача - помочь браузеру понять, как отобразитьинформацию и какого типа информация используется на странице`
    },
    {
        q: `Расскажите о регулярных выражениях`,
        a: `    Регулярные выражения - это шаблоны, которые ичпользуются для сопоставления последовательностей символов в строках
        
    Если проще - то для поиска и замены символов в строке
    
    2 способа создания:
    
    - new RegExp('pattern', 'flags')
    
    - /pattern/flags
    
    Например ищем букву 'n' в слове
    
    const str = prompt('Введите имя);
    const reg = /n/
    console.log(str.search(reg))
    
    Вызываем метод search у той строки, в которой ищем. В ответе зполучим номер элемента первого совпадения. Если совпадений нет, то получим -1
    
    Чтобы искать не просто первое совпадение, а различные варианты, используются флаги
    
    i - ищем без учета регистра
    
    g - ищем все совпадения, а не только первое
    
    m - если строка идет в несколько строк
    
    Метод search не работает с флагом 'g', потому что сам по себе находит только первое совпадение
    
    
    Метод match - возвращает массив, в котором указываетсяпаттерн, индекс, строка, в которой искали. А если будет стоять флаг g, и будет несколько совпадений, то нам вернется массив, в котором будет буква, которую мы ищем, столько раз, сколько раз ее найдет
    
    console.log('java script'.match(/a/g)) // ['a','a']
    
    
    Метод replace - заменяет найденный элемент на другой указанный элемент

    Например заменим все буквы 'a' на '*'
    let str = 'java script';
    console.log(str.replace(/a/g, '*) // 'j*v* script'
    
    
    
    Фишка - если в replace написать /./, то точка - это любой символ. 
    Например 

    let pas = prompt('Введите пароль')
    console.log(pas.replase(/./g, '*')) // все символы заменятся на звездочки
    
    
    А если нужно найти именно точку, то экранируем ее с помощью обратного слэша \
    
    сonsole.log(str.replace(/\.g, '*')) // заменит все точки на звездочки
    
    Также ищем символ слэша /, и другие символы
    
    
    Метод test - возвращает true или false, если найдет или не найдет совпадение/
    Тут немного другой синтаксис: сначала указываем, что ищем, потом, где ищем
    
    let str = 'jsvs script';
    console.log(/a/ig.test(str)) // true, т.к. есть символ 'a'
    
    
    В регулярных выражениях есть специальные классы
    
    /\d/ - ищет все цифры
    /\w/ - ищет все буквы
    /\s/ - ищет все пробелы
    
    console.log(str.match(/\d/g)) // вернет массив с цифрами
    
    Классы можно комбинировать
    
    let str = 'My name is R2D2
    console.log(str.match(/\w\d\w\d/i))
    
    ищем связку буква- цифра- буква- цифра
    
    
    Обратные классы - когда наоборот нужно найти не цифры, не буквы, не пробелы

    Тоже саме, только используем большие буквы

    /\D/ - ищем не цифры
    /\W/ - ищем не буквы
    /\S/ -ищем не пробелы

    Не забываем ставит флаг 'g'

    Допустим задача, нам приходит ширина элемента 200px, нам нужно ее изменить, т.е. нам нужна только цифра 200

    let width = 200px;
    let numWidth = width.replace(/\D/g, '')

    Находим все, что не цифры и заменяем их на пустую строку, остаются только цифры`
    },
    {
        q: `Что такое элемент canvas и для чего он используется?`,
        a: `    canvas или "холст" - это HTML-5 элемент, который можно использовать для вставки изображений, градиентов и сложной анимации
        
    Также он создает область, в которой с помощью js можно рисовать различные объекты`
    },
    {
        q: `Что такое CSS правило?`,
        a: `    CSS- правило, т.е. базовый синтаксис
    Оно состоит из двух основных составляющих
    - селектор
    - свойства, которые будут к нему применятся
    
    Например
    div{
        background-color: blue;
    }`
    },
    {
        q: `Разница между классом и идентификатором в CSS?`,
        a: `    Для добавления стилей лучше всего использовать класс, а для добавления логики через js использовать идентификатор id
        
    У id больший вес. Он может использоваться на странице только один раз, т.е. не может быть несколько элементов с одним id
    
    Class можно вешать на несколько элементов. У одного элемента может быть несколько классов`,
    i: 'id_vs_class'
    },
    {
        q: `Что такое CSS спрайт и для чего он нужен?`,
        a: `    CSS спрайт - это картинка, которая объединяет несколько изображений в одно большое
    
    Грубо говоря, на одной картинке нарисованы несколько иконок, которые используются на сайте
    
    Чтобы не грузить много изображений, не обращаться за этим постоянно к серверу, рисуют их на одной картинке, она загружается, а потом с помощью css указывается, где какая часть этой большой картинки используется, т.е. какая иконка будет видна
    
    Плюс в том, что опять же к серверу рбращаемся только один раз, второе это выполнение предзагрузки пока еще невидимого контента. Иконка, которая появляется при наведении будет уже загружена заранее. В результате не будет видно мигания при смене картинок`
    },
    {
        q: `Как превратить любой тип данных в булевый? Перечислите ложные значения в js`,
        a: `    Чтобы любой тип данных перевести в true или false можно использовать два подхода
    
    1. Boolean() - внутрь передаем данные и получаем true или  false
    
    2. использовать оператор двойного отрицания !!
    
    В JS есть 6 основных элементов, которые возвращают false
    
    - '' пустая строка
    - 0 ноль
    - null
    - undefined
    - NaN
    - false`
    },
    {
        q: `Методы строк в Java Script`,
        a: `    Основные
    
    - length 
    
    - charAt(1) - вернет второй символ
    
    - toUpperCase
    
    - toLowerCase
    
    - indexOf('a') - верне номер элемента, который совпадает с a, или -1, если совпадений нет
    
    - lastIndexOf('a') - вернет номер последнего совпадения
    
    - slice - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substring - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substr - второй параметр - сколько символов обрезать
    
    - replace('a', 'b') - найдет символ 'a' И заменит его на 'b'
    
    - split - разбивает в массив
    
    - includes('a') - вернет true, если в строке есть символ 'a'
    
    - startWidth('a') - вернет true, если строка начинается с 'a', 
    
    - endsWidth('a') - вернет true, если строка заканчивается с 'a'`
    },
    {
        q: `Методы массивов в JS`,
        a: `    Основные
        
    - length
    
    - push - добавить элемент в конец массива
    
    - unshift - добавить элемент в начало
    
    - pop - удалить последний элемент
    
    - shift - удалить первый элемент
    
    - splice - изменяет исходный массив! Удаляет и добавляет новые элементы в массив.
    Первый параметр - номер элемента, который удаляем. Второй параметр - сколько элементов удаляем. Третий - что вставляем вместо них
    
    - slice - не изменяет исходный массив! копирует значения в новый
    
    - join
    
    - toString - также переводит массив в строку
    
    - concat - несколько массивов объединяет в один
    
    - forEach - ничего не возвращает, просто проходит циклом
    
    - map - возвращает новый массив, изменяет элементы
    
    - reduce - запоминает промежуточный результат
    
    - filter - возвращает новый массив с элементами, которые соответствуют условию
    
    - sort - сортирует в в лексическом порядке
    
    - every - вернет true, если все элементы соответствуют условию
    
    - some - вернет true, если хотя бы один элемент соответствует условию`
    }
];

searchQuestion();

function searchQuestion() {
    num = Math.floor(Math.random() * arr.length);
    if(arr[num] === null) {
        searchQuestion();
    } else {
        question.innerText = arr[num].q;
        // question.innerText = arr[4].q;
        console.log(arr[num]);

        answerBtn.addEventListener('click', showAnswer);

        nextQuestionBtn.addEventListener('click', next);
    }
    
}

function showAnswer() {
    answer.innerText = arr[num].a;

    if (arr[num].hasOwnProperty('i')) {
        newImg = document.createElement('img');
        newImg.src = `img/${arr[num].i}.jpg`;
        newImg.style.cssText = 'width: 100%; object-fit: contain; margin: 0 auto; padding-top: 10px';
        
        answerBlock.append(newImg);
    }

    arr[num] = null;
}

function next() {
    arr[num] = null;
    if (answerBlock.children.length > 1) {
    answerBlock.removeChild(newImg);
    }
    answer.innerText = '';

    let flag = arr.every(elem => {
        return elem === null;
    });

    if (flag) {
        clear();
    } else {
        searchQuestion();
    }
}

function clear() {
    question.innerText = 'Вы прошли все вопросы';
    answer.innerText = '';

    answerBtn.removeEventListener('click', showAnswer);
    nextQuestionBtn.removeEventListener('click', next);
}

