let question = document.querySelector('.pre_q');
let answer = document.querySelector('.pre_a');
let answerBtn = document.querySelector('.answer_btn');
let nextQuestionBtn = document.querySelector('.quest_btn');
let answerBlock = document.querySelector('.answer');
let num= 0;
let newImg;


let arr = [
    {
        q: 'Что такое Doctype? Для чего он используется?',
        a: `    Doctype используется для указания типа документа. Он добавляется первой строкой любого HTML документа.

    Служит для того, чтобы браузер мог понять, как ему интерпретировать страницу и в соответствии с каким стандартом парсить страницу`
    },
    {
        q: 'Базовая структура HTML страницы?',
        a: `    Первой строкой обязательно указывается Doctype

    <!DOCTYPE html>

    Затем тег <HTML> - контейнер, в котором содержится все содержимое страницы

    <html lang = 'en'>
    
    Далее тег <head>. Он содержит в себе все необходимые данные о HTML странице (заголовок, описание, SEO информация, подключение стилей,шрифтов)

    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    
    Далее <body>- Содержит в себе всю разметку HTML страницы. Здесь вся видимая часть страницы

    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>Interview assistance</title>
        <link rel="stylesheet" href="css/style.css">
    <body>
    </body>
    </hed>
    </html>`
    },
    {
        q: `Что такое семантика? Какие семантические теги вы знаете?`,
        a: `    Семантика в HTML - это использование правильных тегов, которые описывают содержание контента внутри себя.
        
    Семантичный тег - это тег, который обладает каким-то пояснением своего предназначения.
    
    По тегу должно быть понятно, что внутри него находится.
    
    <header></header> - Шапка сайта

    <footer></footer> - подвал

    <aside></aside> - боковая панель

    <nav></nav> - навигация по сайту

    <main></main> - основное содержимое документа

    <p></p> - параграф

    <h1></h1> - заголовок

    <em></em> - курсив с семантикой

    <strong></strong> - жирный текст с семантикой

    <ul></ul> - маркированный список и т.д.`
    },
    {
        q: `Какая разница между тегами <strong>, <em> и <b>, <i>`,
        a: `    <strong> и <em> предназначены для придания элементу логического выделения.
        
    При чтении страницы поисковыми роботами или screen- ридарами на этих элементах будет сделан акцент`
    },
    {
        q: `Разница между call, apply и bind?`,
        a: `    Из-за запутанности кода может случиться ситуация, когда контекст this будет ссылаться не на тот объект, что нам нужен.
    
    Мы можем сами задать, на какой объект будет ссылаться this в определенной функции.
    
    function showName(firstName, lastName) {
        console.log(firstName + ' ' + lastName)
    }
    
    const user = {
        firstName: 'Ivan',
        lastName: 'Petrov'
    }
    
    Теперь указываем, для функции showName, что this внутри нее должен ссылаться на объукт user.
    
    Для этого есть 3 способа:
    
    call
    
    showName.call(user, 'firstName', 'lastName) - функция showName сразу же вызовется и отработает
    
    apply

    showName.apply(user, ['firstName', 'lastName]) - функция showName сразу же вызовется и отработает

    В call параметры функции записываются через запятые, ихможет быть сколько угодно.
    А в apply может быть только два параметра. Поэтому первый параметр - это всегда объект, а остальные параметры просто записываются внутри массива.

    bind

    showName.bind(user, 'firstName', 'lastName)()

    Параметры также как и в call записфваются через запятую. Но bind не вызывается сразу. Т.е. мы можем передать контекст, а функцию уже вызвать тогда, когда нам это нужно. Либо, если нужно сразу вызвать, то в конце указываем скобки ()`,
    i: 'apply'
    },
    {
        q: 'Что такое делигирование событий?',
        a: `    Делигирование - это прием разработки, когда вместо того, чтобы вешать кучу однотипных обработчиков событий на все элементы, можно добавить всего лишь один обработчик на общего родителя.

    Например: мы создаем таблицу и нам нужно, чтобы при нажатии на ячейку она закрашивалась в какой-либо цвет. Мы не вешаем обработчики на каждую ячейку (ячеек может быть и тысячи, тогда нам понадобятся тысячи обработчиков). Мы вешаем всего один обработчик на саму таблицу. 

    Далее мы просто указываем, что если элемента, по которому мы кликнули - это ячейка, то она должна закраситься нужным цветом`,
    i: 'delegation'
    },
    {
        q: `Что такое CSS и для чего он используется?`,
        a: `    CSS - расшифровывается как каскадня таблица стилей. Предназначена она для для добавления различных стилей на HTML страницу.
        
    На CSS лежит задача добавления на страницу различных визуальных эффектов.
    
    Каскадная- означает, что мы можем подключать стили одновременно несколькими способами и все они будут работать.
    
    Наследование в CSS - означает, что если не указано иное, то конкретный стиль будет унаследован всеми такими же элементами, а также стиль будет применятся ко всем дочерним элементам. 
    
    Например, если мы добавим background-color к div, то все div на страницы изменят цвет и все вложенные элементы в этих div-ах также изменят цвет`
    },
    {
        q: `Варианты добавления CSS стилей на страницу?`,
        a: `    Есть 4 способа: 

    1. <div style="background-color: red></div>
    
    Добавляем стиль конкретному элементу прямо в его теге
    
    2. <head>
            <style>
                div {background-color: red}
            </style>
        </head>
        
    Добавляем стиль в тег <head> к определенным элементам
    
    3. <head>
            <link rel="stylesheet" href="css/style.css">
        </head>
        
    Прикрепляем CSS- файл
    
    4. @import "style/media.css"
        @import "style/footer.css"
       
    Импорты внутри файлов стилей`
    },
    {
        q: `Типы позиционирования в CSS`,
        a: `    Существует 5 типов позиционирования в CSS
        
    1. Static - устанавливается элементам по умолчанию
    
    2. Relative - элемент позиционируется относительно своего текущего положения
    
    3. Absolute - позиционирование отнрсительно другого элемента, у которого позиционирование не Static.
       Если такого элемента нет, то относительно окна браузера

    4. Fixed - позиционирование только относительно окна браузера
    
    5. Sticky - в видимой части экрана элемент ведет себя как fixed. При дальнейшей прокрутке скроллится вместе с родителем`
    },
    {
        q: `Блочная модель CSS?`,
        a: `    Блочная модель позволяет посчитать, какое итоговое пространство будет занимать элемент на странице.
    
    В нее входит:
    
    - сам контент
    
    - padding
    
    - border
    
    - margin
    
    Общий размер элемента- это сумма этих размеров.
    
    Если нам нужно, чтобы размер элемента являлся заданному значению, то используем команду:
    
    box-sizing: border-box
    `,
    i: 'block_model_css'
    },
    {
        q: `Типы данных в CSS?`,
        a: `    В Java Script существует 8 типов данных
        
    1. String
    
    2. Number
    
    3. Bigint
    
    4. Boolean
    
    5. Symbol
    
    6. Object
    
    7. Null
    
    8. Undefined`
    },
    {
        q: `Строгий режим Strict Mode в Java Script?`,
        a: `    Строгий режим позволяет использовать более строгий вариант JS синтаксиса.
        
    Заменяет исключениями некоторые ошибки, которые интерпретатор JS раньше пропускал.
    Более опасные и не полезные черты JS теперь запрещены или приводят к ошибке
    
    Как подключить?

    1. "use strict"

    2. function func() {
            "use strict"
        }

    Строгий режим будет работать только внутри функции

    3. В ES-6 режим добавляется автоматически`
    },
    {
        q: `Какая разница между function declaration и function expression?`,
        a: `    function declaration

    function sum(a,b) {
        return a + b
    }
    
    function expression
    
    let sum = funcrion(a,b) {
        return a + b
    }
    
    function declaration можно вызывать до ее объявления, а function expression нельзя`
    },
    {
        q: `Что такое валидация? Типы проверок HTML - документа?`,
        a: `    Валидация - это проверка документа специальной программой - валидатором на соответствие установленным web стандартам и на обнаружение существующих ошибок.
    
    Эти стандарты называются спецификациями.
    
    Валидатор сначала определяет тип документа, который указывается с помощью Doctype.
    
    Затем проверяет HTML код на правильность и отсутствие ошибок. При этом проверяется правильность имен тегов и их вложенность.
    
    Проверить валидность можно на сайте:
    
    http://validator.w3.org`
    },
    {
        q: `Какой тег использовать, чтобы сверстать кнопку?`,
        a: `    Сразу нужно уточнить, а какая именно кнопка нужна.
        
    1. <button>Нажми</button> - обычная кнопка
    
    2. Кнопки подтверждения формы
    
    <button type="submit">Отправить</button>
    <input type="submit" value="button>
    
    3. <input type="button"> - устаревающий способ
    
    4. <a href="#">Button</a> - кнопка - ссылка. Дальше придаем стили, чтобы чтилизоват ее под кнопку`
    },
    {
        q: `Что такое инлайновый стиль? Можно ли его переопределить?`,
        a: `    Инлайновый стиль - это стиль, примененный к определенному элементу непосредственно в его теге в HTML.
        
    Переопределить его можно с помощью директивы !importmant
    
    <div style="text-align:center"></div>
    
    Чтобы перезаписать его (переопределить) вешаем !importmant на CSS свойство
    
    <style>
        div{text-align:left !importmant}
    </style>`
    },
    {
        q: `Что такое селектор? Какие селекторы существуют?`,
        a: `    Селектор - это часть CSS правила ,которая сообщает браузеру, к какому элементу или элементам web страницы будет применен стиль.
        
    Все селекторы делятся на 2 группы
    
    1. Простые
    
    - .class
    
    - #id
    
    - p (тег)
    
     - * (универсальный селектор. Ставим * и дальше описываются правила(имя, класс и т.д.). Т.е. помогает выбрать абсолютно любой элемент со страницы)
     
     - a[href="text]
     
     2. Составные
     
     - h1, h2, span - перечисляем через запятую
     
     - div p - челектор потомка. Через пробел. Указывать можем всю цепочку воженности
     
     - li > a - селектор только дочернего элемента
     
     - a:hover - селектор псевдокласса
     
     - li:nth-last-child(2n) - селектор псевдоэлемента`
    },
    {
        q:`Что такое специфичность селектора? Как считать вес селектора?`,
        a: `    Специфичность - это способ, с помощью которого брацзер определяет, какие значения CSS свойств будут применены к элементу.
        
    Если на элементе висит сразу несколько свойств, повешенных разными способами, то нужно определить, какое из этих свойств будет применяться`
    },
    {
        q: `Разница между Reset.css и Normalize.css?`,
        a: `    Все HTML элементы обладают дефолтными стилями. И в разных браузерах эти стили разные.
        
    Чтобы во всех браузерах контент выглядел одинаково, перед тем как начинать верстку используют эти два метода.
    
    По сути это CSS файл, который подключается в самом начале доумента.
    
    1. Reset - сбрасывает все стили и их нужно прописовать заново
    
    2. Normalize - прописываем стили, которые должны будут применяться везде одинаково`
    },
    {
        q: `Что такое поднятие (hoisting)?`,
        a: `    Hoisting - это механизм подъема функции или переменной в глобальную или функциональную область видимости
        
    Java Script сначала объявляет, а затем инициализирует переменные.
    
    Переменные, объявленные через var и функции function declaration можно использовать еще до объявления их значений.
    
    Если function declaration мы можем объявить хоть в самом конце кода, то с var работает не так.
    
    Hoisting работает с объявлением, но инициализация будет только в момент присваивания значения.
    
    Т.е. объявить-то var мы можем в самом конце кода, но пока мы не передадим ей какое - либо значение, переменная через var при обращении к ней будет выдавать undefined
    
    А переменные, объявленные через let и const при обращении к ним до их объявления будут выводить не undefined а ошибку
    
    console.log(a); // undefined
    var a = 20;`
    },
    {
        q: `Типы таймеров в Java Script?`,
        a: `    Есть 2 типа таймеров
    1. setTimeout() - вызывает переданную функцию один раз через указанный промежуток времени

    2. setInterval - будет вызывать функцию постоянно через указанные промежутки времени
    
    clearTimeout - позволяет остановить setTimeout до его вызова
    
    clearInterval - позволяет остановить setInterval. Перед этим setInterval записываем в переменную и ее передаем параметром в clearInterval`
    },
    {
        q: `Типы списков в HTML?`,
        a: `    Есть 3 типа списков
    1. Маркированный <ul></ul>
    
    2. Нумерованный <ol></ol>
    
    3. Список определений 
    
    <dl>
        <dt>Определение</dt>
        <dd>Поясняющий текст</dd>
    </dl>`
    },
    {
        q: `Как семантически правильно сверстать картинку с подписью?`,
        a: `    Нужно использовать сначала тег <figure>

    <figure><img><figcaption>Поясняющий текст</figcaption></figure>

    При этом использование этих тегов не отменяет того, что внутри тега <img> нужно указывать alt

    Перед пояснением <figcaption> может идти несколько изображений и тогда пояснение будет одно для них` 
    },
    {
        q: `Разница между display:none и visibility:hidden?`,
        a: `    Оба правила предназначены для того, чтобы скрывать элемент на странице.
        
    display:none - полностью убирает элемент с HTML страницы. Единственное место, где он останется - это DOM дерево
    
    Контент внутри скрытого таким образом блока становится недоступно для поисковых роботов
    
    visibility:hidden - на HTML странице элемент становится не виден, но из основного потока он не вырывается и по прежнему занимает отведенное для него место. А также он остается доступен для поисковых роботов`
    },
    {
        q: `Разница между блочными и строчными (инлайновыми) элементами?`,
        a: `    Основная разница между блочными и строчными элементами в том, что по умолчанию блочный элемент будет занимать всю ширину экрана, а строчнй элемент имеет ширину его содержимого.
        
    Поэтому блочные элементы идут друг под другом, а строчные в одну линию.
    
    Также блочным элементам можно задавать размеры (ширину и высоту), а для строчных это не работает.
    
    Блочные элементы воспринимают margin и padding, а для строчных элементов margin сверху и снизу не работает`
    },
    {
        q: `Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?`,
        a: `    Адаптивный дизайн - это по сути несколько версий одного и того же сайта, которые загружаются пользователю в зависимости от устройства, на котором открыт сайт.
    Пользователь заходит на сайт, браузер определяет тип устройства, с которого пользователь зашел и отправляет его на специально разработанную для этого устройства версию сайта.
        
    Responsive - это один и тот же дизайн, который автоматически сжимается в зависимости от ширины экрана`
    },
    {
        q: `Что такое область видимости (scope)?`,
        a: `    Область видимости или scope - это место, откуда мы имеем доступ к переменным или функциям.
    В JS есть 3 типа областей видимости:
    
    1. Глобальная
    
    2. Функциональная - переменные и функции, объявленные внутри функции доступны только внутри это  функции и всем ее вложенностям
    
    3. Блочная - новая область видимости, которая появилась в ES-6 для переменных, объявленных через let и const
    
    Это область видимости, которая находится между фигурными скобками {}, так называемого блока. Это например (if... else, цикл for)
    
    Переменные, объявленные через var такую область видимости игнорируют. Т.е. если мы внутри if ... else объявим переменную через var, то она просто станет глобальной`
    },
    {
        q: `Разница между var, let и  const`,
        a: `    var - подвержены всплытию. Если мы обратимся к переменной, объявленной через var до присваивания ей значения (до ее инициализации), то получим просто undefined, а у let и const в таком случаем нам выведет ошибку
        
    У let и const область видимости ограничена блоком, т.е. фигурными скобками. У var область видимости ограничена только функцией
    
    Если let и const объявлены внутри фигурных скобок, то они доступны только внутри них и на всех вложенных уровнях
    
    Переменная, объявленная через var такую область видимости игноририрует и может быть видна за ее пределами
    
    const - невозможно переопределить, т.е. нельзя присвоит ей новое значение`
    },
    {
        q: `Что такое функции высшего порядка?`,
        a: `    Функции высшего порядка - это функции, которые возвращают другие функции или же принимают другую ункцию в качестве аргумента
        
    Например: 
    
    let higherOrderFunction = (params, callback) => {
        return callback(params)
    }
    
    К ним относятся такие функции (методы) как :
    
    - map;
    
    - filter
    
    - forEach и т.д.`
    },
    {
        q: `Что такое DOM?`,
        a: `    DOM - это объектная модель документа, которую браузер создает в памяти компьютера на основании HTML кода
        
    Если просто, HTML - это текст, а DOM - это набор связанных объектов, которые создает браузер при парсинге этого текста
    
    Каждый объект соответствует каждому тегу и они вложены друг в друга, как и теги в HTML. Вложенность похожа на форму дерева - поэтому называется DOM- дерево`
    },
    {
        q: `Что такое распространение события (event propogation)?`,
        a: `    Распространение события - это механизм, который отрабатывает когда какое-либо событие происходит в документе
        
    События распространяются от объекта window до вызывающего его элемента. При этом событие последовательно затрагивает всех предков целевого документа
    
    Есть 3 основные фазы распространения событий:
    
    1. capture - событие проходит от корня документа по DOM дереву до целевого элемента. Это фаза захвата
    
    2. target - событие достигает целевого элемента. Обычно его называют event target
    
    3. bubbling - всплытие. Событие возвращается обратно до window, паралельно вызывая все события на родительских элементах`
    },
    {
        q: `Что такое HTML и для чего он используется?`,
        a: `    HTML - это язык гипертекстовой разметки, позволяющий составлять форматированный текст
        
    Данный текст интерпретируется браузером. После чего браузер отображает этот текст на экране в виде элементов web- страницы

    По сути это скелет или каркас любой web- страницы, содержащий разметку

    Основная задача - помочь браузеру понять, как отобразитьинформацию и какого типа информация используется на странице`
    },
    {
        q: `Расскажите о регулярных выражениях`,
        a: `    Регулярные выражения - это шаблоны, которые ичпользуются для сопоставления последовательностей символов в строках
        
    Если проще - то для поиска и замены символов в строке
    
    2 способа создания:
    
    - new RegExp('pattern', 'flags')
    
    - /pattern/flags
    
    Например ищем букву 'n' в слове
    
    const str = prompt('Введите имя);
    const reg = /n/
    console.log(str.search(reg))
    
    Вызываем метод search у той строки, в которой ищем. В ответе зполучим номер элемента первого совпадения. Если совпадений нет, то получим -1
    
    Чтобы искать не просто первое совпадение, а различные варианты, используются флаги
    
    i - ищем без учета регистра
    
    g - ищем все совпадения, а не только первое
    
    m - если строка идет в несколько строк
    
    Метод search не работает с флагом 'g', потому что сам по себе находит только первое совпадение
    
    
    Метод match - возвращает массив, в котором указываетсяпаттерн, индекс, строка, в которой искали. А если будет стоять флаг g, и будет несколько совпадений, то нам вернется массив, в котором будет буква, которую мы ищем, столько раз, сколько раз ее найдет
    
    console.log('java script'.match(/a/g)) // ['a','a']
    
    
    Метод replace - заменяет найденный элемент на другой указанный элемент

    Например заменим все буквы 'a' на '*'
    let str = 'java script';
    console.log(str.replace(/a/g, '*) // 'j*v* script'
    
    
    
    Фишка - если в replace написать /./, то точка - это любой символ. 
    Например 

    let pas = prompt('Введите пароль')
    console.log(pas.replase(/./g, '*')) // все символы заменятся на звездочки
    
    
    А если нужно найти именно точку, то экранируем ее с помощью обратного слэша \
    
    сonsole.log(str.replace(/\.g, '*')) // заменит все точки на звездочки
    
    Также ищем символ слэша /, и другие символы
    
    
    Метод test - возвращает true или false, если найдет или не найдет совпадение/
    Тут немного другой синтаксис: сначала указываем, что ищем, потом, где ищем
    
    let str = 'jsvs script';
    console.log(/a/ig.test(str)) // true, т.к. есть символ 'a'
    
    
    В регулярных выражениях есть специальные классы
    
    /\d/ - ищет все цифры
    /\w/ - ищет все буквы
    /\s/ - ищет все пробелы
    
    console.log(str.match(/\d/g)) // вернет массив с цифрами
    
    Классы можно комбинировать
    
    let str = 'My name is R2D2
    console.log(str.match(/\w\d\w\d/i))
    
    ищем связку буква- цифра- буква- цифра
    
    
    Обратные классы - когда наоборот нужно найти не цифры, не буквы, не пробелы

    Тоже саме, только используем большие буквы

    /\D/ - ищем не цифры
    /\W/ - ищем не буквы
    /\S/ -ищем не пробелы

    Не забываем ставит флаг 'g'

    Допустим задача, нам приходит ширина элемента 200px, нам нужно ее изменить, т.е. нам нужна только цифра 200

    let width = 200px;
    let numWidth = width.replace(/\D/g, '')

    Находим все, что не цифры и заменяем их на пустую строку, остаются только цифры`
    },
    {
        q: `Что такое элемент canvas и для чего он используется?`,
        a: `    canvas или "холст" - это HTML-5 элемент, который можно использовать для вставки изображений, градиентов и сложной анимации
        
    Также он создает область, в которой с помощью js можно рисовать различные объекты`
    },
    {
        q: `Что такое CSS правило?`,
        a: `    CSS- правило, т.е. базовый синтаксис
    Оно состоит из двух основных составляющих
    - селектор
    - свойства, которые будут к нему применятся
    
    Например
    div{
        background-color: blue;
    }`
    },
    {
        q: `Разница между классом и идентификатором в CSS?`,
        a: `    Для добавления стилей лучше всего использовать класс, а для добавления логики через js использовать идентификатор id
        
    У id больший вес. Он может использоваться на странице только один раз, т.е. не может быть несколько элементов с одним id
    
    Class можно вешать на несколько элементов. У одного элемента может быть несколько классов`,
    i: 'id_vs_class'
    },
    {
        q: `Что такое CSS спрайт и для чего он нужен?`,
        a: `    CSS спрайт - это картинка, которая объединяет несколько изображений в одно большое
    
    Грубо говоря, на одной картинке нарисованы несколько иконок, которые используются на сайте
    
    Чтобы не грузить много изображений, не обращаться за этим постоянно к серверу, рисуют их на одной картинке, она загружается, а потом с помощью css указывается, где какая часть этой большой картинки используется, т.е. какая иконка будет видна
    
    Плюс в том, что опять же к серверу рбращаемся только один раз, второе это выполнение предзагрузки пока еще невидимого контента. Иконка, которая появляется при наведении будет уже загружена заранее. В результате не будет видно мигания при смене картинок`
    },
    {
        q: `Как превратить любой тип данных в булевый? Перечислите ложные значения в js`,
        a: `    Чтобы любой тип данных перевести в true или false можно использовать два подхода
    
    1. Boolean() - внутрь передаем данные и получаем true или  false
    
    2. использовать оператор двойного отрицания !!
    
    В JS есть 6 основных элементов, которые возвращают false
    
    - '' пустая строка
    - 0 ноль
    - null
    - undefined
    - NaN
    - false`
    },
    {
        q: `Методы строк в Java Script`,
        a: `    Основные
    
    - length 
    
    - charAt(1) - вернет второй символ
    
    - toUpperCase
    
    - toLowerCase
    
    - indexOf('a') - верне номер элемента, который совпадает с a, или -1, если совпадений нет
    
    - lastIndexOf('a') - вернет номер последнего совпадения
    
    - slice - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substring - второй параметр, элемент, на котором закончится обрезание. Вернет подстроку
    
    - substr - второй параметр - сколько символов обрезать
    
    - replace('a', 'b') - найдет символ 'a' И заменит его на 'b'
    
    - split - разбивает в массив
    
    - includes('a') - вернет true, если в строке есть символ 'a'
    
    - startWidth('a') - вернет true, если строка начинается с 'a', 
    
    - endsWidth('a') - вернет true, если строка заканчивается с 'a'`
    },
    {
        q: `Методы массивов в JS`,
        a: `    Основные
        
    - length
    
    - push - добавить элемент в конец массива
    
    - unshift - добавить элемент в начало
    
    - pop - удалить последний элемент
    
    - shift - удалить первый элемент
    
    - splice - изменяет исходный массив! Удаляет и добавляет новые элементы в массив.
    Первый параметр - номер элемента, который удаляем. Второй параметр - сколько элементов удаляем. Третий - что вставляем вместо них
    
    - slice - не изменяет исходный массив! копирует значения в новый
    
    - join
    
    - toString - также переводит массив в строку
    
    - concat - несколько массивов объединяет в один
    
    - forEach - ничего не возвращает, просто проходит циклом
    
    - map - возвращает новый массив, изменяет элементы
    
    - reduce - запоминает промежуточный результат
    
    - filter - возвращает новый массив с элементами, которые соответствуют условию
    
    - sort - сортирует в в лексическом порядке
    
    - every - вернет true, если все элементы соответствуют условию
    
    - some - вернет true, если хотя бы один элемент соответствует условию`
    },
    {
        q: `Что такое цикл событий (event loop) и как он работает?`,
        a: `    Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти - стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

    Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.
    
    Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая - движок браузера ждет, когда поступит событие. Если непустая первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.`,
    i: 'event_loop',
    },
    {
        q: `Что такое статический метод класса (static)?`,
    a: `    Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.
    Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
    
    class Repo {
    static getName() {
        return "Repo name is modern-js-cheatsheet"
    }
    }

    // нам не нужно создавать объект класса Repo
    console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"

    let r = new Repo();
    console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией`
    },
    {
        q: `Что такое Set, Map, WeakSet и WeakMap?`,
        a: `    В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.

    Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:
    
    'use strict';

    let map = new Map();

    map.set('1', 'str1');   // ключ-строка
    map.set(1, 'num1');     // число
    map.set(true, 'bool1'); // булевое значение

    // в обычном объекте это было бы одно и то же,
    // map сохраняет тип ключа
    alert( map.get(1)   ); // 'num1'
    alert( map.get('1') ); // 'str1'

    alert( map.size ); // 3
    
    
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
    
    'use strict';

    let set = new Set();

    let vasya = {name: "Вася"};
    let petya = {name: "Петя"};
    let dasha = {name: "Даша"};

    // посещения, некоторые пользователи заходят много раз
    set.add(vasya);
    set.add(petya);
    set.add(dasha);
    set.add(vasya);
    set.add(petya);

    // set сохраняет только уникальные значения
    alert( set.size ); // 3

    set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
    
    
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:
    
    // текущие активные пользователи
    let activeUsers = [
    {name: "Вася"},
    {name: "Петя"},
    {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент`
    },
    {
        q: `Какие методы жизненного цикла компонента существуют в React?`,
        a: `    render() — единственный обязательный метод в классовом компоненте.
    При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null
    
    constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
    Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
    Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().
    
    componentDidMount() - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
    Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
    
    componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
    
    componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    
    shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
    
    static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
    Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.
    
    getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
    
    static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().
    
    componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.`,
    i: 'react_metods_life_cicle'
    },
    {
        q: `Что такое Context в React и для чего он используется?`,
        a: `    Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).

    Контекст позволяет избежать передачи пропсов в промежуточные компоненты:
    
    // Контекст позволяет передавать значение глубоко
    // в дерево компонентов без явной передачи пропсов
    // на каждом уровне. Создадим контекст для текущей
    // UI-темы (со значением "light" по умолчанию).
    const ThemeContext = React.createContext('light');
    
    class App extends React.Component {
        render() {
        // Компонент Provider используется для передачи текущей
        // UI-темы вниз по дереву. Любой компонент может использовать
        // этот контекст и не важно, как глубоко он находится.
        // В этом примере мы передаём "dark" в качестве значения контекста.
        return (
            <ThemeContext.Provider value="dark">
            <Toolbar />
            </ThemeContext.Provider>
        );
        }
    }
    
    // Компонент, который находится в середине,
    // теперь не должен явно передавать UI-тему вниз.
    function Toolbar(props) {
        return (
        <div>
            <ThemedButton />
        </div>
        );
    }
    
    class ThemedButton extends React.Component {
        // Определяем contextType, чтобы получить значение контекста.
        // React найдёт (выше по дереву) ближайший Provider-компонент,
        // предоставляющий этот контекст, и использует его значение.
        // В этом примере значение UI-темы будет "dark".
        static contextType = ThemeContext;
        render() {
        return <Button theme={this.context} />;
        }
    }
    Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.
    
    API:
    React.createContext - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
    Context.Provider - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.
    Class.contextType - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.
    Context.Consumer - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext().`
    },
    {
        q: `Что такое Виртуальная DOM?`,
    a: `    Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

    Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.`
    },
    {
        q: `Для чего нужен атрибут key при рендере списков?`,
    a: `    Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.`
    },
    {
        q: `Как работает проп children?`,
    a: `    Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:

    function FancyBorder(props) {
        return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
            {props.children}
        </div>
        );
    }
    Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
    
    function WelcomeDialog() {
        return (
        <FancyBorder color="blue">
            <h1 className="Dialog-title">
            Добро пожаловать
            </h1>
            <p className="Dialog-message">
            Спасибо, что посетили наш космический корабль!
            </p>
        </FancyBorder>
        );
    }
    Всё, что находится внутри JSX-тега , передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.`
    },
    {
        q: `В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?`,
a: `    В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().

В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:

handleChange(event) {
    this.setState({value: event.target.value.toUpperCase()});
}
Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.

class NameForm extends React.Component {
    constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
    }

    handleSubmit(event) {
    alert('Отправленное имя: ' + this.input.current.value);
    event.preventDefault();
    }

    render() {
    return (
        <form onSubmit={this.handleSubmit}>
        <label>
            Имя:
            <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Отправить" />
        </form>
    );
    }
}
Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.`
    },
    {
        q: `Что такое PureComponent?`,
        a: `    React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.

    Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.
    
    Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние`
    },
    {
        q: `Что такое Компонент высшего порядка (Higher-Order Component, HOC)?`,
    a: `    Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.

    const EnhancedComponent = higherOrderComponent(WrappedComponent);
    Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:
    
    const CommentListWithSubscription = withSubscription(
        CommentList,
        (DataSource) => DataSource.getComments()
    );
    
    const BlogPostWithSubscription = withSubscription(
        BlogPost,
        (DataSource, props) => DataSource.getBlogPost(props.id)
    );
    Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.
    
    Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.`
    },
    {
        q: `Что такое порталы в React?`,
    a: `    Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

    ReactDOM.createPortal(child, container)
    Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
    
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.`
    },
    {
        q: `Что такое React Reconciliation (Cверка) и как он работает?`,
        a: `    Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.

    При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.
    
    Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля.
    
    При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
    
    По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.`
    },
    {
        q: `Можно создавать анимации в React?`,
        a: `    React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.`
    },
    {
        q: `Что выведет на экран следующий код?`,
        a: `    function b(x, y, a) {
                arguments[2] = 10;
                alert(a);
                }
                b(1, 2, 3);
        

        




    Ответ: 10

    Пояснение: В функции b 3 аргумента, индексы которых начинаются с [0]. Таким образом, аргумент с индексом [2]  — это a. В первой строке функции третьему аргументу функции присваивается значение 10.`
        
    },
    {
        q: `Что выведет в консоль следующий код?`,
        a: `    console.log(false == undefined);
    console.log(false == null);
    console.log(null == undefined);
    
    
    
    
    
    
    
    
    Ответ: false false true

    Пояснение: == сравнивает на равенство и не проверяет идентичность типов, поэтому в третьей строке кода в консоль будет выведено значение true.`
    },
    {
        q: `Что выведет в консоль следующий код?`,
        a: `    const numbers = [1, 2, 3, 4, 5];
    const [y] = numbers;
    console.log(y);
    
    
    
    
    
    
    
    
    
    
    
    Ответ: 1

    Пояснение: В данном примере выполнена деструктуризация. По умолчанию переменной у присваивается значение первого элемента массива.`
    },
    {
        q: `В каком порядке исполняются скрипты? Почему?`,
        a: `    <script async src="script-1.js"></script> // Время загрузки скрипта 1.5s
    <script src="script-2.js"></script> // Время загрузки скрипта 1s
    <script defer src="script-3.js"></script> // Время загрузки скрипта 3s
    <script defer src="script-4.js"></script> // Время загрузки скрипта 1.5s
    <script src="script-5.js"></script> // Время загрузки скрипта 2s
    <script async src="script-6.js"></script> // Время загрузки скрипта 1s
    <script defer src="script-7.js"></script> // Время загрузки скрипта 0.1s
    
    
    
    
    
    
    
    
    <script src="script-2.js"></script> // Время загрузки скрипта 1s
    <script async src="script-6.js"></script> // Время загрузки скрипта 1s
    <script async src="script-1.js"></script> // Время загрузки скрипта 1.5s
    <script src="script-5.js"></script> // Время загрузки скрипта 2s
    <script defer src="script-3.js"></script> // Время загрузки скрипта 3s
    <script defer src="script-4.js"></script> // Время загрузки скрипта 1.5s
    <script defer src="script-7.js"></script> // Время загрузки скрипта 0.1s
    Пояснение: Когда браузер загружает HTML и доходит до тега <script>...</script>, он не может продолжать строить DOM. Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами <script src="..."></script>: браузер должен подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.

    async: Порядок загрузки (кто загрузится первым, тот и сработает). Может выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кэше, а документ достаточно большой.

    defer: Порядок документа (как расположены в документе). Выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded.

    Поэтому сначала исполнится скрипт 1, поскольку он первый в очереди и по скорости загрузки. Далее 2, потому что у него скорость загрузки такая же быстрая  —  1 секунда. Загрузка асинхронно — вне очереди, 3 скрипт загружается за 1,5 секунды и выполняется сразу после загрузки, затем 4 скрипт загружается в порядке очереди и по скорости 2 секунды, последние скрипты — 5, 6, 7. Они загружаются в конце и в порядке очереди размещения в DOM.`
    },
    {
        q: `то выведет в консоль этот код?`,
        a: `    let x = 3;
    function fn() {
        x = 10;
        return;
        function x() {}
    }
    
    fn();
    console.log(x);
    
    
    
    
    
    
    
    
    
    
    
    Ответ:  3

    Пояснение:  х объявлена как функция, поэтому в итоге она перезаписалась с 10 на 3.`
    }
];

searchQuestion();

function searchQuestion() {
    num = Math.floor(Math.random() * arr.length);
    if(arr[num] === null) {
        searchQuestion();
    } else {
        question.innerText = arr[num].q;
        // question.innerText = arr[4].q;
        console.log(arr[num]);

        answerBtn.addEventListener('click', showAnswer);

        nextQuestionBtn.addEventListener('click', next);
    }
    
}

function showAnswer() {
    answer.innerText = arr[num].a;

    if (arr[num].hasOwnProperty('i')) {
        newImg = document.createElement('img');
        newImg.src = `img/${arr[num].i}.jpg`;
        newImg.style.cssText = 'width: 100%; object-fit: contain; margin: 0 auto; padding-top: 10px';
        
        answerBlock.append(newImg);
    }

    arr[num] = null;
}

function next() {
    arr[num] = null;
    if (answerBlock.children.length > 1) {
    answerBlock.removeChild(newImg);
    }
    answer.innerText = '';

    let flag = arr.every(elem => {
        return elem === null;
    });

    if (flag) {
        clear();
    } else {
        searchQuestion();
    }
}

function clear() {
    question.innerText = 'Вы прошли все вопросы';
    answer.innerText = '';

    answerBtn.removeEventListener('click', showAnswer);
    nextQuestionBtn.removeEventListener('click', next);
}

